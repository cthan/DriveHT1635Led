				;file E:\Doing\啟德電子\DriveHT1635Led\source\main.c
				;1	//___________________________________________________________________
				;2	//___________________________________________________________________
				;3	//Copyright :    2015 by HOLTEK SEMICONDUCTOR INC
				;4	//File Name :    MAIN.C
				;5	//Targer :       
				;6	//MCU :          HT68F40
				;7	//Version :      V00
				;8	//Author :       ChenTing
				;9	//Date :         2015/05/18
				;10	//Description :  MAIN function
				;11	//History : 
				;12	//___________________________________________________________________
				;13	//___________________________________________________________________
				;14	#include "config.h"
				;15	
				;16	volatile unsigned char	displayState;
				;17	volatile unsigned char	BinklState;
				;18	
				;19	
				;20	
				;21	void main()
				;22	{
				@code .SECTION 'CODE'
				include HT68F40.inc
0000	2801	jmp     _main_startup
				startupend1:
				@start .SECTION 'CODE'
000F	2818	jmp     _main
				;23		if (_to == 0 || _pdf ==0){
				@dummy20 .SECTION 'CODE'
				_main:
				_main:
0018	3A8A	snz     TO
0019	281C	jmp     _L2
001A	3E0A	sz      PDF
001B	281E	jmp     _L3
				;24			_clearRam();
				_L2:
001C	2272	call    __clearRam
				;25			_sysinit();
001D	228B	call    __sysinit
				;26		}
				;27		else{	
				;28	
				;29		}
				;30		//power on Display hello
				;31		_init_led();
				_L3:
001E	20B8	call    __init_led
				;32		_updateDisplayHello();
001F	21A1	call    __updateDisplayHello
				;33		while(1){
				;34			if(flag_10ms==1){
				_L11:
0020	7909	snz     flag_byte0[0].2
0021	282F	jmp     _L4
				;35				fun_scan_key();
0022	22D2	call    _fun_scan_key
				;36				fun_task_key();	
0023	22E4	call    _fun_task_key
				;37				flag_10ms=0;	
0024	7509	clr     flag_byte0[0].2
				;38				switch(displayState){
0025	4701	mov     a, displayState[0]
0026	4094	mov     _main_2, a
0027	5094	sz      _main_2
0028	282A	jmp     _LI1
0029	282E	jmp     _L5
				_LI1:
002A	5714	sdza    _main_2
002B	282F	jmp     _L4
				;39					case displayState_Hello:				
				;40						_updateDisplayHello();
				_L5:
002E	21A1	call    __updateDisplayHello
				;41						break;
				;42					case displayState_All:
				;43						_updateDisplayAll();
002C	2211	call    __updateDisplayAll
				;44						break;			
002D	282F	jmp     _L4
				;45	//				case displayState_Off:
				;46	//					_updateDisplayoff();
				;47	//					break;			
				;48	//				case displayState_Bink0:
				;49	//					break;			
				;50	//				case displayState_Bink1:
				;51	//					break;
				;52	//				case displayState_Normal:
				;53	//					_updateDisplayNormal();
				;54	/*					break;	*/				
				;55					default:
				;56						break;	
				;57				}		
				;58			}
				;59			if (flag_3s==1 && displayState==displayState_Bink1)
				_L4:
002F	7889	snz     flag_byte0[0].1
0030	2851	jmp     _L8
0031	4701	mov     a, displayState[0]
0032	0A04	sub     a, 4H
0033	390A	snz     Z
0034	2851	jmp     _L8
				;60			{
				;61				flag_3s=0;
0035	7489	clr     flag_byte0[0].1
				;62				if (BinklState==BinkState_All)
0036	5080	sz      BinklState[0]
0037	2842	jmp     _L10
				;63				{
				;64					BinklState=BinkState_Off;
0038	0F01	mov     a, 1H
0039	4080	mov     BinklState[0], a
				;65					//_updateDisplayoff();
				;66					iicSendCommand( SLAVEMCU1ADD , SYS_SET_COMMAND  , SYS_EN_LED_OFF);
003A	0F02	mov     a, 2H
003B	4092	mov     commandData, a
003C	0F82	mov     a, 82H
003D	4091	mov     command, a
003E	0FD6	mov     a, D6H
003F	20A0	call    _iicSendCommand
				;67					iicSendCommand( SLAVEMCU2ADD , SYS_SET_COMMAND  , SYS_DIS_LED_OFF);
0040	5F12	clr     commandData
0041	284D	jmp     _L18
				;68				}
				;69				else if (BinklState==BinkState_Off)
				_L10:
0042	5700	sdza    BinklState[0]
0043	2851	jmp     _L8
				;70				{
				;71					BinklState=BinkState_All;
0044	5F00	clr     BinklState[0]
				;72					//_updateDisplayAll();
				;73					iicSendCommand( SLAVEMCU1ADD , SYS_SET_COMMAND  , SYS_EN_LED_ON);
0045	0F03	mov     a, 3H
0046	4092	mov     commandData, a
0047	0F82	mov     a, 82H
0048	4091	mov     command, a
0049	0FD6	mov     a, D6H
004A	20A0	call    _iicSendCommand
				;74					iicSendCommand( SLAVEMCU2ADD , SYS_SET_COMMAND  , SYS_EN_LED_ON);
004B	0F03	mov     a, 3H
004C	4092	mov     commandData, a
				_L18:
004D	0F82	mov     a, 82H
004E	4091	mov     command, a
004F	0FD4	mov     a, D4H
0050	20A0	call    _iicSendCommand
				;75				}
				;76			}
				;77			GCC_CLRWDT();
				_L8:
0051	0001	clr     wdt
				;78			GCC_CLRWDT1();
0052	0001	clr     wdt
				;79			GCC_CLRWDT2();	
0053	0005	clr     wdt2
				;80		}		
0054	2820	jmp     _L11
0055	2855	jmp     $
				;81	
				;82	}
				;file E:\Doing\啟德電子\DriveHT1635Led\startup1.asm
				;1	;;--------------------------------------------------------------;;
				;2	;;    This file is part of the Holtek C Compiler V3 package     ;;
				;3	;;    For the initialization of static linkage variables        ;;
				;4	;;    Copyright (C) 2013 Holtek Semiconductor Inc.              ;;
				;5	;;    Version: 1.01 (Above IDE3000 V7.72)                       ;;
				;6	;;    Date:    2013/10/24                                        ;;
				;7	;;--------------------------------------------------------------;;
				;8	
				;9	acc equ [05h]
				;10	mp equ [01h]
				;11	iar equ [00h]
				;12	bp equ [04h]
				;13	z equ [0ah].2
				;14	c equ [0ah].0
				;15	public _main_startup
				;16	@start   .SECTION 'CODE'
				;17	_main_startup:
				;18	 ;;	CLR WDT2    ;;PD,TO flag will be clear. This line can be removed if a small number of global variables in C program are used.
				;19		Mov a, offset __initial_value_end
				_main_startup:
				@start .SECTION 'CODE'
				_main_startup1:
				@start .SECTION 'CODE'
0001	0F8B	mov     a, 8BH
				;20		dec acc
0002	1585	dec     ACC
				;21		MOV mp,A
0003	0081	mov     MP0, a
				;22		clr c
0004	340A	clr     C
				;23		Sub a, offset __initial_value_begin
0005	0A8A	sub     a, 8AH
				;24		snz c
0006	380A	snz     C
				;25		jmp startupend1
0007	280F	jmp     startupend1
				;26	L0004:
				;27		mov ra,a
				L0004:
0008	408B	mov     ra, a
				;28		CALL romdata_base1
0009	2010	call    romdata_base1
				;29		MOV iar,A
000A	0080	mov     [00H], a
				;30		dec mp
000B	1581	dec     MP0
				;31	  ;;	CLR WDT   ;;PD,TO flag will be clear. This line can be removed if a small number of global variables in C program are used.
				;32		deca ra
000C	550B	deca    ra
				;33		sz ra
000D	508B	sz      ra
				;34		jmp L0004 
000E	2808	jmp     L0004
				;35	startupend1:
				;36	  ;;	CLR WDT2  ;;PD,TO flag will be clear. This line can be removed if a small number of global variables in C program are used.
				;37	ROMBANK 0 @ROMDATA_BASE 
				;38	@ROMDATA_BASE .SECTION  inpage com_l 'CODE'
				;39	romdata_base1:
				;40		ADDM A,[06H]
				romdata_base1:
				@ROMDATA_BASE .SECTION 'CODE'
0010	0386	addm    a, PCL
				;41	
				;42	@HCCINIT   .SECTION  COM_L 'DATA'
				;43	__initial_value_begin:
				;44	@HCCINIT  .SECTION COM_E 'DATA'
				;45	__initial_value_end:
				;46	extern ra:byte
				;file E:\Doing\啟德電子\DriveHT1635Led\source\LedDisplay.c
				;1	//___________________________________________________________________
				;2	//___________________________________________________________________
				;3	//Copyright :    2015 by HOLTEK SEMICONDUCTOR INC
				;4	//File Name :    LedDisplay.c
				;5	//Targer :       
				;6	//MCU :          HT64F40
				;7	//Version :      V00
				;8	//Author :       ChenTing
				;9	//Date :         2015/05/18
				;10	//Description :  ledDisplay function
				;11	//History : 
				;12	//___________________________________________________________________
				;13	//___________________________________________________________________
				;14	#include "config.h"
				;15	
				;16	extern unsigned char displayState ;
				;17	
				;18	volatile unsigned char counter =0;
				@ROMDATA_BASE .SECTION 'CODE'
0011	0900	ret     a, 0H
0012	0000	nop
0013	0000	nop
				;19	
				;20	
				;21	const unsigned char	LedDisplayHell0Table[]={
0150	0900	ret     a, 0H
0151	0908	ret     a, 8H
0152	0920	ret     a, 20H
0153	09F8	ret     a, F8H
0154	093F	ret     a, 3FH
0155	0908	ret     a, 8H
0156	0921	ret     a, 21H
0157	0900	ret     a, 0H
0158	0901	ret     a, 1H
0159	0900	ret     a, 0H
015A	0901	ret     a, 1H
015B	0908	ret     a, 8H
015C	0921	ret     a, 21H
015D	09F8	ret     a, F8H
015E	093F	ret     a, 3FH
015F	0908	ret     a, 8H
0160	0920	ret     a, 20H
0161	0900	ret     a, 0H
0162	0900	ret     a, 0H
0163	0900	ret     a, 0H
0164	091F	ret     a, 1FH
0165	0980	ret     a, 80H
0166	0922	ret     a, 22H
0167	0980	ret     a, 80H
0168	0922	ret     a, 22H
0169	0980	ret     a, 80H
016A	0922	ret     a, 22H
016B	0980	ret     a, 80H
016C	0922	ret     a, 22H
016D	0900	ret     a, 0H
016E	0913	ret     a, 13H
016F	0900	ret     a, 0H
0170	0900	ret     a, 0H
0171	0900	ret     a, 0H
0172	0900	ret     a, 0H
0173	0908	ret     a, 8H
0174	0920	ret     a, 20H
0175	0908	ret     a, 8H
0176	0920	ret     a, 20H
0177	09F8	ret     a, F8H
0178	093F	ret     a, 3FH
0179	0900	ret     a, 0H
017A	0920	ret     a, 20H
017B	0900	ret     a, 0H
017C	0920	ret     a, 20H
017D	0900	ret     a, 0H
017E	0900	ret     a, 0H
017F	0900	ret     a, 0H
0180	0900	ret     a, 0H
0181	0900	ret     a, 0H
0182	0900	ret     a, 0H
0183	0908	ret     a, 8H
0184	0920	ret     a, 20H
0185	0908	ret     a, 8H
0186	0920	ret     a, 20H
0187	09F8	ret     a, F8H
0188	093F	ret     a, 3FH
0189	0900	ret     a, 0H
018A	0920	ret     a, 20H
018B	0900	ret     a, 0H
018C	0920	ret     a, 20H
018D	0900	ret     a, 0H
018E	0900	ret     a, 0H
018F	0900	ret     a, 0H
0190	0900	ret     a, 0H
0191	0900	ret     a, 0H
0192	0900	ret     a, 0H
0193	0900	ret     a, 0H
0194	091F	ret     a, 1FH
0195	0980	ret     a, 80H
0196	0920	ret     a, 20H
0197	0980	ret     a, 80H
0198	0920	ret     a, 20H
0199	0980	ret     a, 80H
019A	0920	ret     a, 20H
019B	0980	ret     a, 80H
019C	0920	ret     a, 20H
019D	0900	ret     a, 0H
019E	091F	ret     a, 1FH
019F	0900	ret     a, 0H
01A0	0900	ret     a, 0H
				;22	0x08,0x20,0xF8,0x3F,0x08,0x21,0x00,0x01,
				;23	0x00,0x01,0x08,0x21,0xF8,0x3F,0x08,0x20,/*"H",0*/
				;24	0x00,0x00,0x00,0x1F,0x80,0x22,0x80,0x22,
				;25	0x80,0x22,0x80,0x22,0x00,0x13,0x00,0x00,/*"e",1*/
				;26	0x00,0x00,0x08,0x20,0x08,0x20,0xF8,0x3F,
				;27	0x00,0x20,0x00,0x20,0x00,0x00,0x00,0x00,/*"l",2*/
				;28	0x00,0x00,0x08,0x20,0x08,0x20,0xF8,0x3F,
				;29	0x00,0x20,0x00,0x20,0x00,0x00,0x00,0x00,/*"l",3*/
				;30	0x00,0x00,0x00,0x1F,0x80,0x20,0x80,0x20,
				;31	0x80,0x20,0x80,0x20,0x00,0x1F,0x00,0x00/*"o",4*/
				;32	};
				;33	const unsigned char LedDisplayNormalTable[]={
				L0100:
0100	0386	addm    a, PCL
0101	0900	ret     a, 0H
0102	0900	ret     a, 0H
0103	0900	ret     a, 0H
0104	0900	ret     a, 0H
0105	0900	ret     a, 0H
0106	0900	ret     a, 0H
0107	09F8	ret     a, F8H
0108	090F	ret     a, FH
0109	0980	ret     a, 80H
010A	0900	ret     a, 0H
010B	0980	ret     a, 80H
010C	0900	ret     a, 0H
010D	0980	ret     a, 80H
010E	0900	ret     a, 0H
010F	09F8	ret     a, F8H
0110	090F	ret     a, FH
0111	0900	ret     a, 0H
0112	0900	ret     a, 0H
0113	09F0	ret     a, F0H
0114	0907	ret     a, 7H
0115	0908	ret     a, 8H
0116	0908	ret     a, 8H
0117	0908	ret     a, 8H
0118	0908	ret     a, 8H
0119	0908	ret     a, 8H
011A	0908	ret     a, 8H
011B	09F0	ret     a, F0H
011C	0907	ret     a, 7H
011D	0900	ret     a, 0H
011E	0900	ret     a, 0H
011F	09F8	ret     a, F8H
0120	090F	ret     a, FH
0121	0900	ret     a, 0H
0122	0908	ret     a, 8H
0123	0900	ret     a, 0H
0124	0908	ret     a, 8H
0125	0900	ret     a, 0H
0126	0908	ret     a, 8H
0127	0900	ret     a, 0H
0128	0908	ret     a, 8H
0129	0900	ret     a, 0H
012A	0900	ret     a, 0H
012B	0908	ret     a, 8H
012C	0900	ret     a, 0H
012D	0908	ret     a, 8H
012E	0900	ret     a, 0H
012F	09F8	ret     a, F8H
0130	090F	ret     a, FH
0131	0908	ret     a, 8H
0132	0900	ret     a, 0H
0133	0908	ret     a, 8H
0134	0900	ret     a, 0H
0135	0900	ret     a, 0H
0136	0900	ret     a, 0H
0137	09F8	ret     a, F8H
0138	090F	ret     a, FH
0139	0988	ret     a, 88H
013A	0908	ret     a, 8H
013B	0988	ret     a, 88H
013C	0908	ret     a, 8H
013D	0988	ret     a, 88H
013E	0908	ret     a, 8H
013F	0908	ret     a, 8H
0140	0908	ret     a, 8H
0141	0900	ret     a, 0H
0142	0900	ret     a, 0H
0143	09F8	ret     a, F8H
0144	090F	ret     a, FH
0145	0980	ret     a, 80H
0146	0900	ret     a, 0H
0147	0960	ret     a, 60H
0148	0903	ret     a, 3H
0149	0918	ret     a, 18H
014A	090C	ret     a, CH
014B	0900	ret     a, 0H
014C	0900	ret     a, 0H
014D	0900	ret     a, 0H
014E	0900	ret     a, 0H
014F	0900	ret     a, 0H
				;34	0X00,0X00,0X00,0X00,
				;35	0x00,0x00,0xF8,0x0F,0x80,0x00,0x80,0x00,
				;36	0x80,0x00,0xF8,0x0F,				/*"H",0*/
				;37	0x00,0x00,0xF0,0x07,0x08,0x08,0x08,0x08,
				;38	0x08,0x08,0xF0,0x07,				/*"O",1*/
				;39	0x00,0x00,0xF8,0x0F,0x00,0x08,0x00,0x08,
				;40	0x00,0x08,0x00,0x08,				/*"L",2*/
				;41	0x00,0x00,0x08,0x00,0x08,0x00,0xF8,0x0F,
				;42	0x08,0x00,0x08,0x00,				/*"T",3*/
				;43	0x00,0x00,0xF8,0x0F,0x88,0x08,0x88,0x08,
				;44	0x88,0x08,0x08,0x08,				/*"E",4*/
				;45	0x00,0x00,0xF8,0x0F,0x80,0x00,0x60,0x03,
				;46	0x18,0x0C,0x00,0x00,				/*"K",5*/
				;47	0X00,0X00,0X00,0X00
				;48	};
				;49	
				;50	
				;51	/*****************************
				;52	 *@描述 上電對led1 & led2 初始化
				;53	 *@參數 無
				;54	 *@返回 無
				;55	 ****************************/
				;56	void _init_led(void){
				;57		//init HT1635B 1 
				;58		iicSendCommand( SLAVEMCU1ADD , SYS_SET_COMMAND    , SYS_LED_DEFAULT1    );
				__init_led:
				__init_led:
00B8	0F03	mov     a, 3H
00B9	4092	mov     commandData, a
00BA	0F82	mov     a, 82H
00BB	4091	mov     command, a
00BC	0FD6	mov     a, D6H
00BD	20A0	call    _iicSendCommand
				;59		iicSendCommand( SLAVEMCU1ADD , BLINK_FRQ_COMMAND  , BLINK_DEFAULT	    );
00BE	5F12	clr     commandData
00BF	0F84	mov     a, 84H
00C0	4091	mov     command, a
00C1	0FD6	mov     a, D6H
00C2	20A0	call    _iicSendCommand
				;60		iicSendCommand( SLAVEMCU1ADD , DRIVE_OUT_COMMAMND , DRIVE_TYPE_DEFAULT1 );
00C3	0F01	mov     a, 1H
00C4	4092	mov     commandData, a
00C5	0F88	mov     a, 88H
00C6	4091	mov     command, a
00C7	0FD6	mov     a, D6H
00C8	20A0	call    _iicSendCommand
				;61		iicSendCommand( SLAVEMCU1ADD , CASCADE_COMMAND    , CASCADE_DEFAULT1    );
00C9	0F05	mov     a, 5H
00CA	4092	mov     commandData, a
00CB	0FA0	mov     a, A0H
00CC	4091	mov     command, a
00CD	0FD6	mov     a, D6H
00CE	20A0	call    _iicSendCommand
				;62		iicSendCommand( SLAVEMCU1ADD , PWM_DUTY_COMMAND   , PWM_DUTY_DEFAULT1   );
00CF	0F09	mov     a, 9H
00D0	4092	mov     commandData, a
00D1	0FC0	mov     a, C0H
00D2	4091	mov     command, a
00D3	0FD6	mov     a, D6H
00D4	20A0	call    _iicSendCommand
				;63		//init HT1635B 2
				;64		iicSendCommand( SLAVEMCU2ADD , SYS_SET_COMMAND    , SYS_LED_DEFAULT2    );
00D5	0F03	mov     a, 3H
00D6	4092	mov     commandData, a
00D7	0F82	mov     a, 82H
00D8	4091	mov     command, a
00D9	0FD4	mov     a, D4H
00DA	20A0	call    _iicSendCommand
				;65		iicSendCommand( SLAVEMCU2ADD , BLINK_FRQ_COMMAND  , BLINK_DEFAULT		);
00DB	5F12	clr     commandData
00DC	0F84	mov     a, 84H
00DD	4091	mov     command, a
00DE	0FD4	mov     a, D4H
00DF	20A0	call    _iicSendCommand
				;66		iicSendCommand( SLAVEMCU2ADD , DRIVE_OUT_COMMAMND , DRIVE_TYPE_DEFAULT2 );
00E0	0F01	mov     a, 1H
00E1	4092	mov     commandData, a
00E2	0F88	mov     a, 88H
00E3	4091	mov     command, a
00E4	0FD4	mov     a, D4H
00E5	20A0	call    _iicSendCommand
				;67		iicSendCommand( SLAVEMCU2ADD , CASCADE_COMMAND    , CASCADE_DEFAULT2	);
00E6	5F12	clr     commandData
00E7	0FA0	mov     a, A0H
00E8	4091	mov     command, a
00E9	0FD4	mov     a, D4H
00EA	20A0	call    _iicSendCommand
				;68		iicSendCommand( SLAVEMCU2ADD , PWM_DUTY_COMMAND   , PWM_DUTY_DEFAULT2	);
00EB	0F09	mov     a, 9H
00EC	4092	mov     commandData, a
00ED	0FC0	mov     a, C0H
00EE	4091	mov     command, a
00EF	0FD4	mov     a, D4H
00F0	20A0	call    _iicSendCommand
				;69		//power on Display hello
				;70		_updateDisplayHello();
00F1	21A1	call    __updateDisplayHello
				;71		displayState=displayState_Hello;	
00F2	5F01	clr     displayState[0]
00F3	0003	ret
00F4	1483	inc     MP1
				L00F5:
00F5	3F87	sz      TBLP.7
00F6	28FB	jmp     L00FB
00F7	0707	mov     a, TBLP
00F8	0084	mov     BP, a
00F9	0702	mov     a, __iar1[0]
00FA	0003	ret
				L00FB:
00FB	0703	mov     a, MP1
00FC	2900	jmp     L0100
00FD	0000	nop
00FE	0000	nop
00FF	0000	nop
				;72	}
				;73	/**************************
				;74	 *@描述 設定LED閃爍mode (利用MCU內部的Blink mode)
				;75	 *@參數 無
				;76	 *@返回 無
				;77	 *************************/
				;78	void _updateDisplayBlink(void){
				;79		_updateDisplayAll();	
				;80		iicSendCommand( SLAVEMCU1ADD , SYS_SET_COMMAND  , SYS_EN_LED_ON);
				;81		iicSendCommand( SLAVEMCU2ADD , SYS_SET_COMMAND  , SYS_EN_LED_ON);
				;82		iicSendCommand( SLAVEMCU1ADD , BLINK_FRQ_COMMAND , BLINK_1HZ );
				;83		iicSendCommand( SLAVEMCU2ADD , BLINK_FRQ_COMMAND , BLINK_1HZ );
				;84	}
				;85	/***************************
				;86	 *@描述 顯示hello
				;87	 *@參數 無
				;88	 &@返回 無
				;89	 *************************/
				;90	void _updateDisplayHello(void){
				;91		iicSendCommand( SLAVEMCU1ADD , SYS_SET_COMMAND  , SYS_EN_LED_ON);
				__updateDisplayHello:
				__updateDisplayHello:
01A1	0F03	mov     a, 3H
01A2	4092	mov     commandData, a
01A3	0F82	mov     a, 82H
01A4	4091	mov     command, a
01A5	0FD6	mov     a, D6H
01A6	20A0	call    _iicSendCommand
				;92		iicSendCommand( SLAVEMCU2ADD , SYS_SET_COMMAND  , SYS_EN_LED_ON);
01A7	0F03	mov     a, 3H
01A8	4092	mov     commandData, a
01A9	0F82	mov     a, 82H
01AA	4091	mov     command, a
01AB	0FD4	mov     a, D4H
01AC	20A0	call    _iicSendCommand
				;93		iicSendCommand( SLAVEMCU1ADD , BLINK_FRQ_COMMAND  , BLINK_OFF);
01AD	5F12	clr     commandData
01AE	0F84	mov     a, 84H
01AF	4091	mov     command, a
01B0	0FD6	mov     a, D6H
01B1	20A0	call    _iicSendCommand
				;94		iicSendCommand( SLAVEMCU2ADD , BLINK_FRQ_COMMAND  , BLINK_OFF);
01B2	5F12	clr     commandData
01B3	0F84	mov     a, 84H
01B4	4091	mov     command, a
01B5	0FD4	mov     a, D4H
01B6	20A0	call    _iicSendCommand
				;95	//update HT1635B 1 data
				;96		iicStart();
01B7	205C	call    _iicStart
				;97		//發送HT1635B 1 IIC地址
				;98		iicWrite(SLAVEMCU1ADD);	
01B8	0FD6	mov     a, D6H
01B9	2088	call    _iicWrite
				;99		if (TestAck()==1){
01BA	2071	call    _TestAck
01BB	408B	mov     ra, a
01BC	570B	sdza    ra
01BD	29C0	jmp     _L2
				;100			iicStop();
				_L3:
01BE	2067	call    _iicStop
01BF	2A10	jmp     _L31
				;101			return;
				;102		}
				;103		//發送寫數據命令
				;104		iicWrite(SEND_DATA_COMMAND);
				_L2:
01C0	0F80	mov     a, 80H
01C1	2088	call    _iicWrite
				;105		if (TestAck()==1){
01C2	2071	call    _TestAck
01C3	408B	mov     ra, a
01C4	570B	sdza    ra
01C5	29C7	jmp     _LI1
01C6	29BE	jmp     _L3
				;106			iicStop();
				;107			return;
				;108		}
				;109		//發送寫入起始地址
				;110		iicWrite(0X00);				
				_LI1:
01C7	0F00	mov     a, 0H
01C8	2088	call    _iicWrite
				;111		if (TestAck()==1){
01C9	2071	call    _TestAck
01CA	408B	mov     ra, a
01CB	570B	sdza    ra
01CC	29CE	jmp     _LI2
01CD	29BE	jmp     _L3
				;112			iicStop();
				;113			return;
				;114		}
				;115		//循環寫入HT1635B 1的數據
				;116		for (counter=0; counter < 80; counter=counter+2){
				_LI2:
01CE	5F0A	clr     counter[0]
				_L4:
01CF	0F4F	mov     a, 4FH
01D0	420A	sub     a, counter[0]
01D1	380A	snz     C
01D2	29E3	jmp     _L32
				_LI3:
01E0	0F02	mov     a, 2H
01E1	438A	addm    a, counter[0]
01E2	29CF	jmp     _L4
				;117			iicWrite(LedDisplayHell0Table[counter]);
01D3	0F50	mov     a, 50H
01D4	430A	add     a, counter[0]
01D5	0083	mov     MP1, a
01D6	0F80	mov     a, 80H
01D7	1F07	clr     TBLP
01D8	1387	adcm    a, TBLP
01D9	20F5	call    L00F5
01DA	2088	call    _iicWrite
				;118			if (TestAck()==1){
01DB	2071	call    _TestAck
01DC	408B	mov     ra, a
01DD	570B	sdza    ra
01DE	29E0	jmp     _LI3
01DF	29BE	jmp     _L3
				;119				iicStop();
				;120				return;
				;121			}
				;122		}
				;123		//HT1635B 1的數據寫入完成，停止IIC
				;124		iicStop();
				_L32:
01E3	2067	call    _iicStop
				;125	
				;126	//update HT1635B 2 data
				;127		iicStart();
01E4	205C	call    _iicStart
				;128		//發送HT1635B 2 IIC地址
				;129		iicWrite(SLAVEMCU2ADD);
01E5	0FD4	mov     a, D4H
01E6	2088	call    _iicWrite
				;130		if (TestAck()==1){
01E7	2071	call    _TestAck
01E8	408B	mov     ra, a
01E9	570B	sdza    ra
01EA	29EC	jmp     _LI4
01EB	29BE	jmp     _L3
				;131			iicStop();
				;132			return;
				;133		}
				;134		//發送寫數據命令
				;135		iicWrite(SEND_DATA_COMMAND);
				_LI4:
01EC	0F80	mov     a, 80H
01ED	2088	call    _iicWrite
				;136		if (TestAck()==1){
01EE	2071	call    _TestAck
01EF	408B	mov     ra, a
01F0	570B	sdza    ra
01F1	29F3	jmp     _LI5
01F2	29BE	jmp     _L3
				;137			iicStop();
				;138			return;
				;139		}
				;140		//發送寫入起始地址
				;141		iicWrite(0X00);
				_LI5:
01F3	0F00	mov     a, 0H
01F4	2088	call    _iicWrite
				;142		if (TestAck()==1){
01F5	2071	call    _TestAck
01F6	408B	mov     ra, a
01F7	570B	sdza    ra
01F8	29FA	jmp     _LI6
01F9	29BE	jmp     _L3
				;143			iicStop();
				;144			return;
				;145		}
				;146		//循環寫入HT1635B 2的數據
				;147		for (counter = 1; counter < 80; counter=counter+2){
				_LI6:
01FA	0F01	mov     a, 1H
01FB	408A	mov     counter[0], a
				_L6:
01FC	0F4F	mov     a, 4FH
01FD	420A	sub     a, counter[0]
01FE	380A	snz     C
01FF	29BE	jmp     _L3
				_LI7:
020D	0F02	mov     a, 2H
020E	438A	addm    a, counter[0]
020F	29FC	jmp     _L6
				_L31:
0210	0003	ret
				;148			iicWrite(LedDisplayHell0Table[counter]);
0200	0F50	mov     a, 50H
0201	430A	add     a, counter[0]
0202	0083	mov     MP1, a
0203	0F80	mov     a, 80H
0204	1F07	clr     TBLP
0205	1387	adcm    a, TBLP
0206	20F5	call    L00F5
0207	2088	call    _iicWrite
				;149			if (TestAck()==1){
0208	2071	call    _TestAck
0209	408B	mov     ra, a
020A	570B	sdza    ra
020B	2A0D	jmp     _LI7
020C	29BE	jmp     _L3
				;150				iicStop();
				;151				return;
				;152			}
				;153		}
				;154		//HT1635B 2的數據寫入完成，停止IIC
				;155		iicStop();	
				;156	}
				;157	/***********************
				;158	顯示HOLTEK
				;159	
				;160	**********/
				;161	void _updateDisplayNormal(void){
				;162		iicSendCommand( SLAVEMCU1ADD , SYS_SET_COMMAND  , SYS_EN_LED_ON);
				;163		iicSendCommand( SLAVEMCU2ADD , SYS_SET_COMMAND  , SYS_EN_LED_ON);
				;164		iicSendCommand( SLAVEMCU1ADD , BLINK_FRQ_COMMAND  , BLINK_OFF);
				;165		iicSendCommand( SLAVEMCU2ADD , BLINK_FRQ_COMMAND  , BLINK_OFF);
				;166	//update HT1635B 1 data
				;167		iicStart();
				;168		//發送HT1635B 1 IIC地址
				;169		iicWrite(SLAVEMCU1ADD);
				;170		if (TestAck()==1){
				;171			iicStop();
				;172			return;
				;173		}
				;174		//發送寫數據命令	
				;175		iicWrite(SEND_DATA_COMMAND);
				;176		if (TestAck()==1){
				;177			iicStop();
				;178			return;
				;179		}
				;180		//發送寫入起始地址
				;181		iicWrite(0X00);
				;182		if (TestAck()==1){
				;183			iicStop();
				;184			return;
				;185		}
				;186		//循環寫入HT1635B 1的數據
				;187		for (counter=0; counter < 80; counter=counter+2){
				;188			iicWrite(LedDisplayNormalTable[counter]);
				;189			if (TestAck()==1){
				;190				iicStop();
				;191				return;
				;192			}
				;193		}
				;194		//HT1635B 1的數據寫入完成，停止IIC
				;195		iicStop();
				;196	
				;197	//update HT1635B 2 data
				;198		iicStart();
				;199		//發送HT1635B 2 IIC地址
				;200		iicWrite(SLAVEMCU2ADD);
				;201		if (TestAck()==1){
				;202			iicStop();
				;203			return;
				;204		}
				;205		//發送寫數據命令
				;206		iicWrite(SEND_DATA_COMMAND);
				;207		if (TestAck()==1){
				;208			iicStop();
				;209			return;
				;210		}
				;211		//發送寫入起始地址
				;212		iicWrite(0X00);
				;213		if (TestAck()==1){
				;214			iicStop();
				;215			return;
				;216		}
				;217		//循環寫入HT1635B 2的數據
				;218		for (counter = 1; counter < 80; counter=counter+2){
				;219			iicWrite(LedDisplayNormalTable[counter]);
				;220			if (TestAck()==1){
				;221				iicStop();
				;222				return;
				;223			}
				;224		}
				;225	}
				;226	/***********************
				;227	全亮
				;228	**********/
				;229	void _updateDisplayAll(void){
				;230		iicSendCommand( SLAVEMCU1ADD , SYS_SET_COMMAND  , SYS_EN_LED_ON);
				__updateDisplayAll:
				__updateDisplayAll:
0211	0F03	mov     a, 3H
0212	4092	mov     commandData, a
0213	0F82	mov     a, 82H
0214	4091	mov     command, a
0215	0FD6	mov     a, D6H
0216	20A0	call    _iicSendCommand
				;231		iicSendCommand( SLAVEMCU2ADD , SYS_SET_COMMAND  , SYS_EN_LED_ON);
0217	0F03	mov     a, 3H
0218	4092	mov     commandData, a
0219	0F82	mov     a, 82H
021A	4091	mov     command, a
021B	0FD4	mov     a, D4H
021C	20A0	call    _iicSendCommand
				;232		iicSendCommand( SLAVEMCU1ADD , BLINK_FRQ_COMMAND  , BLINK_OFF);
021D	5F12	clr     commandData
021E	0F84	mov     a, 84H
021F	4091	mov     command, a
0220	0FD6	mov     a, D6H
0221	20A0	call    _iicSendCommand
				;233		iicSendCommand( SLAVEMCU2ADD , BLINK_FRQ_COMMAND  , BLINK_OFF);
0222	5F12	clr     commandData
0223	0F84	mov     a, 84H
0224	4091	mov     command, a
0225	0FD4	mov     a, D4H
0226	20A0	call    _iicSendCommand
				;234	//Display all HT1635B 1
				;235	//	iicStart();
				;236	//	//發送HT1635B 1 IIC地址
				;237	//	iicWrite(SLAVEMCU1ADD);
				;238	//	if (TestAck()==1){
				;239	//		iicStop();
				;240	//		return;
				;241	//	}
				;242	//	//發送寫數據命令
				;243	//	iicWrite(SEND_DATA_COMMAND);
				;244	//	if (TestAck()==1){
				;245	//		iicStop();
				;246	//		return;
				;247	//	}
				;248	//	//發送寫入起始地址
				;249	//	iicWrite(0X00);
				;250	//	if (TestAck()==1){
				;251	//		iicStop();
				;252	//		return;
				;253	//	}
				;254	//	//循環寫入HT1635B 1的數據
				;255	//	for (counter = 0; counter < 44; counter++){
				;256	//		iicWrite(0Xff);
				;257	//		if (TestAck()==1){
				;258	//			iicStop();
				;259	//			return;
				;260	//		}
				;261	//	}
				;262		//Display all HT1635B 2
				;263		iicStart();
0227	205C	call    _iicStart
				;264		//發送HT1635B 2 IIC地址
				;265		iicWrite(SLAVEMCU2ADD);
0228	0FD4	mov     a, D4H
0229	2088	call    _iicWrite
				;266		if (TestAck()==1){
022A	2071	call    _TestAck
022B	408B	mov     ra, a
022C	570B	sdza    ra
022D	2A30	jmp     _L65
				;267			iicStop();
				_L66:
022E	2067	call    _iicStop
022F	2A71	jmp     _L93
				;268			return;
				;269		}
				;270		//發送寫數據命令
				;271		iicWrite(SEND_DATA_COMMAND);
				_L65:
0230	0F80	mov     a, 80H
0231	2088	call    _iicWrite
				;272		if (TestAck()==1){
0232	2071	call    _TestAck
0233	408B	mov     ra, a
0234	570B	sdza    ra
0235	2A37	jmp     _LI15
0236	2A2E	jmp     _L66
				;273			iicStop();
				;274			return;
				;275		}
				;276		//發送寫入起始地址
				;277		iicWrite(0X00);
				_LI15:
0237	0F00	mov     a, 0H
0238	2088	call    _iicWrite
				;278		if (TestAck()==1){
0239	2071	call    _TestAck
023A	408B	mov     ra, a
023B	570B	sdza    ra
023C	2A3E	jmp     _LI16
023D	2A2E	jmp     _L66
				;279			iicStop();
				;280			return;
				;281		}
				;282		//循環寫入HT1635B 2的數據
				;283		for (counter = 0; counter < 44; counter++){
				_LI16:
023E	5F0A	clr     counter[0]
				_L67:
023F	0F2B	mov     a, 2BH
0240	420A	sub     a, counter[0]
0241	380A	snz     C
0242	2A4C	jmp     _L94
				_LI17:
024A	548A	inc     counter[0]
024B	2A3F	jmp     _L67
				;284			iicWrite(0Xff);
0243	0FFF	mov     a, FFH
0244	2088	call    _iicWrite
				;285			if (TestAck()==1){
0245	2071	call    _TestAck
0246	408B	mov     ra, a
0247	570B	sdza    ra
0248	2A4A	jmp     _LI17
0249	2A2E	jmp     _L66
				;286				iicStop();
				;287				return;
				;288			}
				;289		}
				;290		iicStop();
				_L94:
024C	2067	call    _iicStop
				;291		iicStart();
024D	205C	call    _iicStart
				;292		//發送HT1635B 1 IIC地址
				;293		iicWrite(SLAVEMCU1ADD);
024E	0FD6	mov     a, D6H
024F	2088	call    _iicWrite
				;294		if (TestAck()==1){
0250	2071	call    _TestAck
0251	408B	mov     ra, a
0252	570B	sdza    ra
0253	2A55	jmp     _LI18
0254	2A2E	jmp     _L66
				;295			iicStop();
				;296			return;
				;297		}
				;298		//發送寫數據命令
				;299		iicWrite(SEND_DATA_COMMAND);
				_LI18:
0255	0F80	mov     a, 80H
0256	2088	call    _iicWrite
				;300		if (TestAck()==1){
0257	2071	call    _TestAck
0258	408B	mov     ra, a
0259	570B	sdza    ra
025A	2A5C	jmp     _LI19
025B	2A2E	jmp     _L66
				;301			iicStop();
				;302			return;
				;303		}
				;304		//發送寫入起始地址
				;305		iicWrite(0X00);
				_LI19:
025C	0F00	mov     a, 0H
025D	2088	call    _iicWrite
				;306		if (TestAck()==1){
025E	2071	call    _TestAck
025F	408B	mov     ra, a
0260	570B	sdza    ra
0261	2A63	jmp     _LI20
0262	2A2E	jmp     _L66
				;307			iicStop();
				;308			return;
				;309		}
				;310		//循環寫入HT1635B 1的數據
				;311		for (counter = 0; counter < 44; counter++){
				_LI20:
0263	5F0A	clr     counter[0]
				_L69:
0264	0F2B	mov     a, 2BH
0265	420A	sub     a, counter[0]
0266	380A	snz     C
0267	2A2E	jmp     _L66
				_LI21:
026F	548A	inc     counter[0]
0270	2A64	jmp     _L69
				_L93:
0271	0003	ret
				;312			iicWrite(0Xff);
0268	0FFF	mov     a, FFH
0269	2088	call    _iicWrite
				;313			if (TestAck()==1){
026A	2071	call    _TestAck
026B	408B	mov     ra, a
026C	570B	sdza    ra
026D	2A6F	jmp     _LI21
026E	2A2E	jmp     _L66
				;314				iicStop();
				;315				return;
				;316			}
				;317		}
				;318		iicStop();
				;319	}
				;320	/***********************
				;321	全滅
				;322	
				;323	**********/
				;324	void _updateDisplayoff(void){
				;325		iicSendCommand( SLAVEMCU1ADD , SYS_SET_COMMAND  , SYS_EN_LED_ON);
				;326		iicSendCommand( SLAVEMCU2ADD , SYS_SET_COMMAND  , SYS_EN_LED_ON);
				;327		iicSendCommand( SLAVEMCU1ADD , BLINK_FRQ_COMMAND  , BLINK_OFF);
				;328		iicSendCommand( SLAVEMCU2ADD , BLINK_FRQ_COMMAND  , BLINK_OFF);
				;329		//Display off HT1635B 1
				;330		iicStart();
				;331		//發送HT1635B 1 IIC地址
				;332		iicWrite(SLAVEMCU1ADD);
				;333		if (TestAck()==1){
				;334			iicStop();
				;335			return;
				;336		}
				;337		//發送寫數據命令
				;338		iicWrite(SEND_DATA_COMMAND);
				;339		if (TestAck()==1){
				;340			iicStop();
				;341			return;
				;342		}
				;343		//發送寫入起始地址
				;344		iicWrite(0X00);
				;345		if (TestAck()==1){
				;346			iicStop();
				;347			return;
				;348		}
				;349		//循環寫入HT1635B 1的數據
				;350		for (counter = 0; counter < 44; counter++){
				;351			iicWrite(0X00);
				;352			if (TestAck()==1){
				;353				iicStop();
				;354				return;
				;355			}
				;356		}
				;357		//Display off HT1635B 2
				;358		iicStart();
				;359		//發送HT1635B 2 IIC地址
				;360		iicWrite(SLAVEMCU2ADD);
				;361		if (TestAck()==1){
				;362			iicStop();
				;363			return;
				;364		}
				;365		//發送寫數據命令
				;366		iicWrite(SEND_DATA_COMMAND);
				;367		if (TestAck()==1){
				;368			iicStop();
				;369			return;
				;370		}
				;371		//發送寫入起始地址	
				;372		iicWrite(0X00);
				;373		if (TestAck()==1){
				;374			iicStop();
				;375			return;
				;376		}
				;377		//循環寫入HT1635B 2的數據
				;378		for (counter = 0; counter < 44; counter++){
				;379			iicWrite(0X00);
				;380			if (TestAck()==1){
				;381				iicStop();
				;382				return;
				;383			}
				;384		}
				;385	}
				;386	
				;387	
				;388	
				;file E:\Doing\啟德電子\DriveHT1635Led\source\sysinit.c
				;1	//___________________________________________________________________
				;2	//___________________________________________________________________
				;3	//Copyright :    2015 by HOLTEK SEMICONDUCTOR INC
				;4	//File Name :    sysinit.c
				;5	//Targer :       
				;6	//MCU :          HT68F40
				;7	//Version :      V00
				;8	//Author :       ChenTing
				;9	//Date :         2015/05/18
				;10	//Description :  config system
				;11	//History : 
				;12	//___________________________________________________________________
				;13	//___________________________________________________________________
				;14	#include "config.h"
				;15	
				;16	
				;17	
				;18	
				;19	volatile unsigned char counter10ms;
				;20	volatile unsigned int  counter3s;
				;21	extern unsigned char  keyCount;
				;22	
				;23	void _clearRam(void){
				;24		_bp = 0x00;
				__clearRam:
				__clearRam:
0272	1F04	clr     BP
				;25		_mp1 = 0x80;
0273	0F80	mov     a, 80H
0274	0083	mov     MP1, a
				;26			for(_tblp = 0x00;_tblp < 128;_tblp++)
0275	1F07	clr     TBLP
				_L2:
0276	3F87	sz      TBLP.7
0277	2A7C	jmp     _L7
027A	1487	inc     TBLP
027B	2A76	jmp     _L2
				;27			{
				;28				 _iar1 = 0;
0278	1F02	clr     __iar1[0]
				;29				  _mp1++;
0279	1483	inc     MP1
				;30			}
				;31		_bp = 0x01;
				_L7:
027C	0F01	mov     a, 1H
027D	0084	mov     BP, a
				;32		_mp1 = 0x80;		
027E	0F80	mov     a, 80H
027F	0083	mov     MP1, a
				;33			for(_tblp = 0x00;_tblp < 64;_tblp++)
0280	1F07	clr     TBLP
				_L4:
0281	0F3F	mov     a, 3FH
0282	0207	sub     a, TBLP
0283	380A	snz     C
0284	2A89	jmp     _L8
0287	1487	inc     TBLP
0288	2A81	jmp     _L4
				;34			{
				;35				 _iar1 = 0;
0285	1F02	clr     __iar1[0]
				;36				  _mp1++;
0286	1483	inc     MP1
				;37			}
				;38		_bp=0x00;
				_L8:
0289	1F04	clr     BP
028A	0003	ret
				;39		}
				;40	
				;41	void _reset_init(void){
				;42		_sysinit();
				;43		}
				;44	
				;45	//
				;46	void _sysinit(void){
				;47	//IO
				;48		_pac=0;
				__sysinit:
				__sysinit:
028B	1F1B	clr     PAC
				;49		_pa=0;
028C	1F1A	clr     PA
				;50		_papu=0xff;
028D	1F99	set     PAPU
				;51		_pawu=1;
028E	0F01	mov     a, 1H
028F	0098	mov     PAWU, a
				;52		
				;53		_pbc=0;
0290	1F1E	clr     PBC
				;54		_pb=0;
0291	1F1D	clr     PB
				;55		_pbpu=0xff;
0292	1F9C	set     PBPU
				;56		
				;57		_pcc=0;
0293	1F21	clr     PCC
				;58		_pc=0;
0294	1F20	clr     PC
				;59		_pcpu=0xff;
0295	1F9F	set     PCPU
				;60		
				;61		_pdc=0;
0296	1F24	clr     PDC
				;62		_pd=0;
0297	1F23	clr     PD
				;63		_pdpu=0xff;
0298	1FA2	set     PDPU
				;64		
				;65		_pec=0;
0299	1F27	clr     PEC
				;66		_pe=0;
029A	1F26	clr     PE
				;67		_pepu=0xff;
029B	1FA5	set     PEPU
				;68		
				;69		_pfc=0;
029C	1F2A	clr     PFC
				;70		_pf=0;
029D	1F29	clr     PF
				;71		_pfpu=0xff;	
029E	1FA8	set     PFPU
				;72		
				;73	//cp
				;74		_cp0c=0;
029F	1F34	clr     CP0C
				;75		_cp1c=0;	
02A0	1F35	clr     CP1C
				;76	//Timer
				;77		_tm0c0=0x00;
02A1	1F3A	clr     TM0C0
				;78		_tm0c1=0xc1;
02A2	0FC1	mov     a, C1H
02A3	00BB	mov     TM0C1, a
				;79		_tm0al=0xe8;
02A4	0FE8	mov     a, E8H
02A5	00BE	mov     TM0AL, a
				;80		_tm0ah=0x03;
02A6	0F03	mov     a, 3H
02A7	00BF	mov     TM0AH, a
				;81		_mf0f=0;
02A8	3691	clr     MF0F
				;82		_mf0e=1;
02A9	3091	set     MF0E
				;83		_t0ae=1;
02AA	3094	set     T0AE
				;84		_t0af=0;
02AB	3694	clr     T0AF
				;85		_emi=1;
02AC	3010	set     EMI
				;86		_t0on=1;
02AD	31BA	set     T0ON
				;87	//Ram
				;88		counter10ms=10;
02AE	0F0A	mov     a, AH
02AF	4084	mov     counter10ms[0], a
				;89		counter3s=300;
02B0	0F2C	mov     a, 2CH
02B1	4082	mov     counter3s[0], a
02B2	0F01	mov     a, 1H
02B3	4083	mov     counter3s[1], a
				;90		keyCount=0;
02B4	5F08	clr     keyCount[0]
				;91		flag_byte0.byte=0;
02B5	5F09	clr     flag_byte0[0]
02B6	0003	ret
				;92		}
				;93		
				;94	DEFINE_ISR(timer0, 0x14){
				@timer0_code .SECTION 'CODE'
0014	408C	mov     r114, a
0015	0704	mov     a, BP
0016	408D	mov     r214, a
0017	2AB7	jmp     _timer0
				_timer0:
				_timer0:
02B7	070A	mov     a, STATUS
02B8	408E	mov     r314, a
				;95	//	flag_1ms=1;
				;96		counter10ms--;
02B9	5784	sdz     counter10ms[0]
02BA	2ACB	jmp     _L13
				;97		if(counter10ms==0){
				;98			flag_10ms=1;
02BB	7109	set     flag_byte0[0].2
				;99			counter10ms=10;	
02BC	0F0A	mov     a, AH
02BD	4084	mov     counter10ms[0], a
				;100			counter3s--;
02BE	0FFF	mov     a, FFH
02BF	4382	addm    a, counter3s[0]
02C0	0FFF	mov     a, FFH
02C1	5383	adcm    a, counter3s[1]
				;101			if(counter3s==0){
02C2	4702	mov     a, counter3s[0]
02C3	4503	or      a, counter3s[1]
02C4	390A	snz     Z
02C5	2ACB	jmp     _L13
				;102				flag_3s=1;
02C6	7089	set     flag_byte0[0].1
				;103				counter3s=300;
02C7	0F2C	mov     a, 2CH
02C8	4082	mov     counter3s[0], a
02C9	0F01	mov     a, 1H
02CA	4083	mov     counter3s[1], a
				;104			}
				;105		}	
				;106		_t0af=0;
				_L13:
02CB	3694	clr     T0AF
02CC	470D	mov     a, r214
02CD	0084	mov     BP, a
02CE	470E	mov     a, r314
02CF	008A	mov     STATUS, a
02D0	470C	mov     a, r114
02D1	0004	reti
				;107	}
				;file E:\Doing\啟德電子\DriveHT1635Led\source\IIC.c
				;1	//___________________________________________________________________
				;2	//___________________________________________________________________
				;3	//Copyright :    2015 by HOLTEK SEMICONDUCTOR INC
				;4	//File Name :    IIC.C
				;5	//Targer :       
				;6	//MCU :          HT64F50
				;7	//Version :      V00
				;8	//Author :       ChenTing
				;9	//Date :         2015/05/18
				;10	//Description :  IIC function
				;11	//History : 
				;12	//___________________________________________________________________
				;13	//___________________________________________________________________
				;14	#include "config.h"
				;15	
				;16	
				;17	
				;18	/**********************************
				;19	IIC設置命令發送程序
				;20	**********************************/
				;21	void iicSendCommand(unsigned char address, unsigned char command,unsigned char commandData)
				;22	{
				_iicSendCommand:
				_iicSendCommand:
00A0	4093	mov     address[0], a
				;23		iicStart();
00A1	205C	call    _iicStart
				;24		iicWrite(address);
00A2	4713	mov     a, address[0]
00A3	2088	call    _iicWrite
				;25		if (TestAck()==1){
00A4	2071	call    _TestAck
00A5	408B	mov     ra, a
00A6	570B	sdza    ra
00A7	28AA	jmp     L00AA
				;26			iicStop();
				L00A8:
00A8	2067	call    _iicStop
00A9	28B7	jmp     L00B7
				;27			return;
				;28		}
				;29		iicWrite(command);
				L00AA:
00AA	4711	mov     a, command[0]
00AB	2088	call    _iicWrite
				;30		if (TestAck()==1){
00AC	2071	call    _TestAck
00AD	408B	mov     ra, a
00AE	570B	sdza    ra
00AF	28B1	jmp     L00B1
00B0	28A8	jmp     L00A8
				;31			iicStop();
				;32			return;
				;33		}
				;34		iicWrite(commandData);
				L00B1:
00B1	4712	mov     a, commandData[0]
00B2	408B	mov     ra, a
00B3	470B	mov     a, ra
00B4	2088	call    _iicWrite
				;35		if (TestAck()==1){
00B5	2071	call    _TestAck
00B6	28A8	jmp     L00A8
				L00B7:
00B7	0003	ret
				;36			iicStop();
				;37			return;
				;38		}
				;39		iicStop();
				;40	}
				;41	
				;42	/**********************************
				;43	I2C啟動信號
				;44	**********************************/
				;45	void iicStart(void)
				;46	{
				;47		SDAC=0;//設定SDA腳為輸出
				_iicStart:
				_iicStart:
005C	371B	clr     PAC6
				;48		SCLC=0;//設定SCL腳為輸出
005D	379B	clr     PAC7
				;49		SDA=1;_delay();
005E	331A	set     PA6
005F	2056	call    __delay
				;50		SCL=1;_delay();	//SCL=1 & SDA=1
0060	339A	set     PA7
0061	2056	call    __delay
				;51		SDA=0;_delay();	//SCL=1 & SDA=0 IIC Start flag	
0062	371A	clr     PA6
0063	2056	call    __delay
				;52		SCL=0;_delay();	//SCL=0		
0064	379A	clr     PA7
0065	2056	call    __delay
0066	0003	ret
				;53	}
				;54	
				;55	/**********************************
				;56	I2C停止信號
				;57	**********************************/
				;58	void iicStop(void)
				;59	{
				;60		SDAC=0;//設定SDA腳為輸出
				_iicStop:
				_iicStop:
0067	371B	clr     PAC6
				;61		SDA=0;_delay();//SDA=0
0068	371A	clr     PA6
0069	2056	call    __delay
				;62		SCL=1;_delay();//SCL=1
006A	339A	set     PA7
006B	2056	call    __delay
				;63		SDA=1;_delay();//SDA=1
006C	331A	set     PA6
006D	2056	call    __delay
				;64		SCL=0;_delay();//SCL=0	
006E	379A	clr     PA7
006F	2056	call    __delay
0070	0003	ret
				;65	}
				;66	//**********************************
				;67	//ACK(0)信號信號，通知從幾已讀取資料
				;68	//或后面還有資料
				;69	//**********************************
				;70	void Ack(void)
				;71	{
				;72		SDAC=0;//設定SDA腳為輸出
				;73		SDA=0;_delay();//SDA=0
				;74		SCL=1;_delay();//SCL=1
				;75		SCL=0;_delay();//SCL=0
				;76		SDA=1;_delay();//SDA=1
				;77	}
				;78	//**********************************
				;79	//NoAck(1)信號信號，通知從幾無資料讀取
				;80	//**********************************
				;81	void NoAck(void)
				;82	{
				;83		SDAC=0;//設定SDA腳為輸出
				;84		SDA=1;_delay();//SDA=1
				;85		SCL=1;_delay();//SCL=1
				;86		SCL=0;_delay();//SCL=0
				;87	}
				;88	//**********************************
				;89	//主機檢查從幾回傳的ACK信號
				;90	//0為ACK完成動作，1為未完成動作
				;91	//**********************************
				;92	unsigned char TestAck(void)
				;93	{	
				;94		volatile unsigned char ErrTime=0;//
				_TestAck:
				_TestAck:
0071	5F0F	clr     ErrTime[0]
				;95		SDAC=1;_delay();	//設定SDA腳為輸入
0072	331B	set     PAC6
0073	2056	call    __delay
				;96		SCL =1;_delay();	//SCL=1
0074	339A	set     PA7
0075	2056	call    __delay
				;97		while(SDA==1){
				_L7:
0076	071A	mov     a, PA
0077	0E40	and     a, 40H
0078	4090	mov     Data, a
0079	5090	sz      Data
007A	287C	jmp     _LI1
007B	2884	jmp     _L12
				;98			ErrTime++;
				_LI1:
007C	548F	inc     ErrTime[0]
				;99			if (ErrTime>250){
007D	0FFA	mov     a, FAH
007E	420F	sub     a, ErrTime[0]
007F	3C0A	sz      C
0080	2876	jmp     _L7
				;100				return 1;
0081	0F01	mov     a, 1H
0082	4090	mov     Data, a
0083	2886	jmp     _L8
				;101			}
				;102		}
				;103		SCL=0;_delay();
				_L12:
0084	379A	clr     PA7
0085	2056	call    __delay
				;104		return 0;
				;105	}
				_L8:
0086	4710	mov     a, Data
0087	0003	ret
				;106	//**********************************
				;107	//主機將資料以串列方式發射出去
				;108	//**********************************
				;109	void iicWrite(unsigned char Data)
				;110	{
				_iicWrite:
				_iicWrite:
0088	4090	mov     Data[0], a
				;111		volatile unsigned char count=8;
0089	0F08	mov     a, 8H
008A	408F	mov     count[0], a
				;112		SDAC=0;//設定SDA腳為輸出
008B	371B	clr     PAC6
				;113		while(count--)
008C	2899	jmp     L0099
				L0099:
0099	470F	mov     a, count[0]
009A	408B	mov     ra, a
009B	550B	deca    ra
009C	408F	mov     count[0], a
009D	508B	sz      ra
009E	288D	jmp     L008D
009F	0003	ret
				;114		{
				;115	//		SDA=(Data & 0x80);_delay();//取出資料的bit7送到SDA腳	
				;116	//		SCL=1;_delay();//送出i2c時鐘脈沖
				;117	//		SCL=0;_delay();
				;118	//		Data=Data<<1;	//資料左移一位
				;119	
				;120			if((Data & 0x80)==0){
				L008D:
008D	7F90	sz      Data[0].7
008E	2891	jmp     L0091
				;121				SDA=0;
008F	371A	clr     PA6
0090	2892	jmp     L0092
				;122			}
				;123			else{
				;124				SDA=1;
				L0091:
0091	331A	set     PA6
				;125			}
				;126			_delay();
				L0092:
0092	2056	call    __delay
				;127			SCL=1;_delay();//送出i2c時鐘脈沖
0093	339A	set     PA7
0094	2056	call    __delay
				;128			SCL=0;_delay();
0095	379A	clr     PA7
0096	2056	call    __delay
				;129			Data=Data<<1;	//資料左移一位		
0097	4710	mov     a, Data[0]
0098	4390	addm    a, Data[0]
				;130	
				;131		}
				;132	}
				;133	//**********************************
				;134	//主機讀取資料
				;135	//**********************************
				;136	unsigned char iicRead(void)
				;137	{
				;138		volatile unsigned char count=8,Data=0;
				;139		SDAC=1;//設定SDA腳為輸入
				;140		while(count--)
				;141		{
				;142			SCL=1;_delay();
				;143			Data=Data<<1;//資料左移一位
				;144			Data=Data|((unsigned char)(SDA));//讀取串bit與Data合并
				;145			SCL=0;
				;146		}	
				;147		return(Data);
				;148	}
				;149	void _delay(void){
				;150		GCC_NOP();
				__delay:
				__delay:
				@dummy .SECTION 'CODE'
0056	0000	nop
				;151		GCC_NOP();
0057	0000	nop
				;152		GCC_NOP();
0058	0000	nop
				;153		GCC_NOP();
0059	0000	nop
				;154		GCC_NOP();
005A	0000	nop
005B	0003	ret
				;155	}
				;156	
				;157	
				;158	
				;159	
				;file E:\Doing\啟德電子\DriveHT1635Led\source\funscankey.c
				;1	#include "config.h"
				;2	
				;3	volatile unsigned char keyCount;
				;4	unsigned char keychk;
				;5	unsigned char keytemp;
				;6	unsigned char keychat;
				;7	extern unsigned char modecount;
				;8	extern unsigned char displayState;
				;9	extern unsigned char BinklState;
				;10	extern unsigned int counter3s;
				;11	
				;12	void fun_scan_key(void){
				;13		KEYC=1;//key input mode
				_fun_scan_key:
				_fun_scan_key:
02D2	321B	set     PAC4
				;14	//	keytemp=pa & 0x10;	//PA4
				;15	//
				;16	//	if(keytemp!=keychk){
				;17	//		flag_keyin=1;
				;18	//		keychk=keytemp;
				;19	//		keychat=4;
				;20	//	}
				;21	//	else if(flag_keyin==1){
				;22	//		keychat--;
				;23	//		
				;24	//
				;25	//	}
				;26		if (KEY==0){
02D3	3E1A	sz      PA4
02D4	2ADB	jmp     _L2
				;27			keyCount++;
02D5	5488	inc     keyCount[0]
				;28			if(keyCount==3)
02D6	4708	mov     a, keyCount[0]
02D7	0A03	sub     a, 3H
02D8	390A	snz     Z
02D9	2ADC	jmp     _L3
				;29			{
				;30				flag_keypush=1;
02DA	7009	set     flag_byte0[0].0
				;31				keyCount=0;
				;32			}
				;33		}
				;34		else{
				;35			keyCount=0;
				_L2:
02DB	5F08	clr     keyCount[0]
				;36		}	
				;37		if(flag_keypush==1&&KEY==1){
				_L3:
02DC	7809	snz     flag_byte0[0].0
02DD	2AE3	jmp     _L1
02DE	3A1A	snz     PA4
02DF	2AE3	jmp     _L1
				;38			flag_keypush=0;
02E0	7409	clr     flag_byte0[0].0
				;39			flag_keypop=1;
02E1	7289	set     flag_byte0[0].5
				;40			keyCount=0;
02E2	5F08	clr     keyCount[0]
				_L1:
02E3	0003	ret
				;41		}
				;42		
				;43	}
				;44	
				;45	
				;46	void fun_task_key(void){
				;47		if(flag_keypop==1){
				_fun_task_key:
				_fun_task_key:
02E4	7A89	snz     flag_byte0[0].5
02E5	2B0B	jmp     _L12
				;48			flag_keypop=0;
02E6	7689	clr     flag_byte0[0].5
				;49			switch(displayState){
02E7	4701	mov     a, displayState[0]
02E8	0A00	sub     a, 0H
02E9	3D0A	sz      Z
02EA	2AF4	jmp     _L14
02EB	0A01	sub     a, 1H
02EC	3D0A	sz      Z
02ED	2AF7	jmp     _L15
02EE	4701	mov     a, displayState[0]
02EF	0A04	sub     a, 4H
02F0	390A	snz     Z
02F1	2B0B	jmp     _L12
				;50				case displayState_Hello:
				;51					displayState=displayState_All;
				_L14:
02F4	0F01	mov     a, 1H
02F5	4081	mov     displayState[0], a
				;52					break;
02F6	2B0B	jmp     _L12
				;53				case displayState_All:
				;54					displayState=displayState_Bink1;
				_L15:
02F7	0F04	mov     a, 4H
02F8	4081	mov     displayState[0], a
				;55					iicSendCommand( SLAVEMCU1ADD , SYS_SET_COMMAND  , SYS_EN_LED_OFF);
02F9	0F02	mov     a, 2H
02FA	4092	mov     commandData, a
02FB	0F82	mov     a, 82H
02FC	4091	mov     command, a
02FD	0FD6	mov     a, D6H
02FE	20A0	call    _iicSendCommand
				;56					iicSendCommand( SLAVEMCU2ADD , SYS_SET_COMMAND  , SYS_DIS_LED_OFF);
02FF	5F12	clr     commandData
0300	0F82	mov     a, 82H
0301	4091	mov     command, a
0302	0FD4	mov     a, D4H
0303	20A0	call    _iicSendCommand
				;57					BinklState=BinkState_Off;
0304	0F01	mov     a, 1H
0305	4080	mov     BinklState[0], a
				;58					flag_3s=0;
0306	7489	clr     flag_byte0[0].1
				;59					counter3s=300;
0307	0F2C	mov     a, 2CH
0308	4082	mov     counter3s[0], a
0309	0F01	mov     a, 1H
030A	4083	mov     counter3s[1], a
				_L12:
030B	0003	ret
				;60					break;				
				;61				case displayState_Bink1:
				;62					displayState=displayState_Hello;
02F2	5F01	clr     displayState[0]
				;63					break;				
02F3	2B0B	jmp     _L12
				;64	//			case displayState_All:
				;65	//				displayState=displayState_Bink0;
				;66	//				_updateDisplayBlink();
				;67	//				break;
				;68	//			case displayState_Bink0:
				;69	//				displayState=displayState_Bink1;
				;70	//				_updateDisplayAll();
				;71	//				break;
				;72	//			case displayState_Bink1:
				;73	//				displayState=displayState_Normal;
				;74	//				break;
				;75	//			case displayState_Normal:
				;76	//				displayState=displayState_Off;
				;77	//				break;
				;78	//			case displayState_Off:
				;79	//				displayState=displayState_Hello;
				;80	//				break;
				;81				default:
				;82					break;
				;83			}
				;84		}	
				;85	}
				;86	
				;87	
				;88	
				data .SECTION 'DATA'
				__iar1 DB DUP (?) ; __iar1
				__mp1 DB DUP (?) ; __mp1
				__bp DB DUP (?) ; __bp
				__tblp DB DUP (?) ; __tblp
				__status DB DUP (?) ; __status
				__intc0 DB DUP (?) ; __intc0
				__intc1 DB DUP (?) ; __intc1
				__mfi0 DB DUP (?) ; __mfi0
				__pawu DB DUP (?) ; __pawu
				__papu DB DUP (?) ; __papu
				__pa DB DUP (?) ; __pa
				__pac DB DUP (?) ; __pac
				__pbpu DB DUP (?) ; __pbpu
				__pb DB DUP (?) ; __pb
				__pbc DB DUP (?) ; __pbc
				__pcpu DB DUP (?) ; __pcpu
				__pc DB DUP (?) ; __pc
				__pcc DB DUP (?) ; __pcc
				__pdpu DB DUP (?) ; __pdpu
				__pd DB DUP (?) ; __pd
				__pdc DB DUP (?) ; __pdc
				__pepu DB DUP (?) ; __pepu
				__pe DB DUP (?) ; __pe
				__pec DB DUP (?) ; __pec
				__pfpu DB DUP (?) ; __pfpu
				__pf DB DUP (?) ; __pf
				__pfc DB DUP (?) ; __pfc
				__cp0c DB DUP (?) ; __cp0c
				__cp1c DB DUP (?) ; __cp1c
				__tm0c0 DB DUP (?) ; __tm0c0
				__tm0c1 DB DUP (?) ; __tm0c1
				__tm0al DB DUP (?) ; __tm0al
				__tm0ah DB DUP (?) ; __tm0ah
				BinklState DB DUP (?) ; BinklState
				displayState DB DUP (?) ; displayState
				counter3s DB 2 DUP (?) ; counter3s
				counter10ms DB DUP (?) ; counter10ms
				keychat DB DUP (?) ; keychat
				keytemp DB DUP (?) ; keytemp
				keychk DB DUP (?) ; keychk
				keyCount DB DUP (?) ; keyCount
				flag_byte0 DB DUP (?) ; flag_byte0
				counter DB DUP (?) ; counter
				ra DB DUP (?)
				r114 DB DUP (?)
				r214 DB DUP (?)
				r314 DB DUP (?)
				count DB DUP (?) ; count
				Data DB DUP (?) ; Data
				command DB DUP (?) ; command
				commandData DB DUP (?) ; commandData
				address DB DUP (?) ; address
				_main_2 DB DUP (?)
