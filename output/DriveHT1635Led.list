				;file E:\Doing\啟德電子\DriveHT1635Led\source\main.c
				;1	//___________________________________________________________________
				;2	//___________________________________________________________________
				;3	//Copyright :    2015 by HOLTEK SEMICONDUCTOR INC
				;4	//File Name :    MAIN.C
				;5	//Targer :       
				;6	//MCU :          HT68F40
				;7	//Version :      V00
				;8	//Author :       ChenTing
				;9	//Date :         2015/05/18
				;10	//Description :  MAIN function
				;11	//History : 
				;12	//___________________________________________________________________
				;13	//___________________________________________________________________
				;14	#include "config.h"
				;15	
				;16	volatile unsigned char	displayState;
				;17	volatile unsigned char	BinklState;
				;18	
				;19	
				;20	
				;21	void main()
				;22	{
				@code .SECTION 'CODE'
				include HT68F40.inc
0000	2801	jmp     _main_startup
				startupend1:
				@start .SECTION 'CODE'
000F	2818	jmp     _main
				;23		if (_to == 0 || _pdf ==0){
				@dummy20 .SECTION 'CODE'
				_main:
				_main:
0018	3A8A	snz     TO
0019	281C	jmp     _L2
001A	3E0A	sz      PDF
001B	281E	jmp     _L3
				;24			_clearRam();
				_L2:
001C	2311	call    __clearRam
				;25			_sysinit();
001D	232A	call    __sysinit
				;26		}
				;27		else{	
				;28	
				;29		}
				;30		//power on Display hello
				;31		_init_led();
				_L3:
001E	20B5	call    __init_led
				;32		_updateDisplayHello();
001F	21A1	call    __updateDisplayHello
				;33		while(1){
				;34			//key scan
				;35	//		if (flag_1ms==1){
				;36	//			flag_1ms=0;
				;37	//			fun_scan_key();
				;38	//			fun_task_key();				
				;39	//		}
				;40			if(flag_10ms==1){
				_L13:
0020	7906	snz     flag_byte0[0].2
0021	283D	jmp     _L4
				;41				fun_scan_key();
0022	2371	call    _fun_scan_key
				;42				fun_task_key();	
0023	237C	call    _fun_task_key
				;43				flag_10ms=0;	
0024	7506	clr     flag_byte0[0].2
				;44				switch(displayState){
0025	4701	mov     a, displayState[0]
0026	4091	mov     _main_2, a
0027	4711	mov     a, _main_2
0028	0A00	sub     a, 0H
0029	3D0A	sz      Z
002A	2838	jmp     _L5
002B	0A01	sub     a, 1H
002C	3D0A	sz      Z
002D	283A	jmp     _L6
002E	4711	mov     a, _main_2
002F	0A02	sub     a, 2H
0030	3D0A	sz      Z
0031	283C	jmp     _L7
0032	4711	mov     a, _main_2
0033	0A05	sub     a, 5H
0034	390A	snz     Z
0035	283D	jmp     _L4
				;45					case displayState_Hello:				
				;46					_updateDisplayHello();
				_L5:
0038	21A1	call    __updateDisplayHello
				;47					break;
0039	283D	jmp     _L4
				;48					case displayState_All:
				;49						_updateDisplayAll();
				_L6:
003A	2269	call    __updateDisplayAll
				;50						break;			
003B	283D	jmp     _L4
				;51					case displayState_Off:
				;52						_updateDisplayoff();
				_L7:
003C	22BD	call    __updateDisplayoff
				;53						break;			
				;54					case displayState_Bink0:
				;55						break;			
				;56					case displayState_Bink1:
				;57						break;
				;58					case displayState_Normal:
				;59						_updateDisplayNormal();
0036	2205	call    __updateDisplayNormal
				;60						break;					
0037	283D	jmp     _L4
				;61					default:
				;62						break;	
				;63				}		
				;64			}
				;65			if (flag_3s==1 && displayState==displayState_Bink1)
				_L4:
003D	7886	snz     flag_byte0[0].1
003E	284E	jmp     _L10
003F	4701	mov     a, displayState[0]
0040	0A04	sub     a, 4H
0041	390A	snz     Z
0042	284E	jmp     _L10
				;66			{
				;67				flag_3s=0;
0043	7486	clr     flag_byte0[0].1
				;68				if (BinklState==BinkState_All)
0044	5080	sz      BinklState[0]
0045	284A	jmp     _L12
				;69				{
				;70					BinklState=BinkState_Off;
0046	0F01	mov     a, 1H
0047	4080	mov     BinklState[0], a
				;71					_updateDisplayoff();
0048	22BD	call    __updateDisplayoff
0049	284E	jmp     _L10
				;72				}
				;73				else if (BinklState==BinkState_Off)
				_L12:
004A	5700	sdza    BinklState[0]
004B	284E	jmp     _L10
				;74				{
				;75					BinklState=BinkState_All;
004C	5F00	clr     BinklState[0]
				;76					_updateDisplayAll();
004D	2269	call    __updateDisplayAll
				;77				}
				;78			}
				;79			GCC_CLRWDT();
				_L10:
004E	0001	clr     wdt
				;80			GCC_CLRWDT1();
004F	0001	clr     wdt
				;81			GCC_CLRWDT2();	
0050	0005	clr     wdt2
				;82		}		
0051	2820	jmp     _L13
0052	2852	jmp     $
				;83	
				;84	}
				;file E:\Doing\啟德電子\DriveHT1635Led\startup1.asm
				;1	;;--------------------------------------------------------------;;
				;2	;;    This file is part of the Holtek C Compiler V3 package     ;;
				;3	;;    For the initialization of static linkage variables        ;;
				;4	;;    Copyright (C) 2013 Holtek Semiconductor Inc.              ;;
				;5	;;    Version: 1.01 (Above IDE3000 V7.72)                       ;;
				;6	;;    Date:    2013/10/24                                        ;;
				;7	;;--------------------------------------------------------------;;
				;8	
				;9	acc equ [05h]
				;10	mp equ [01h]
				;11	iar equ [00h]
				;12	bp equ [04h]
				;13	z equ [0ah].2
				;14	c equ [0ah].0
				;15	public _main_startup
				;16	@start   .SECTION 'CODE'
				;17	_main_startup:
				;18	 ;;	CLR WDT2    ;;PD,TO flag will be clear. This line can be removed if a small number of global variables in C program are used.
				;19		Mov a, offset __initial_value_end
				_main_startup:
				@start .SECTION 'CODE'
				_main_startup1:
				@start .SECTION 'CODE'
0001	0F88	mov     a, 88H
				;20		dec acc
0002	1585	dec     ACC
				;21		MOV mp,A
0003	0081	mov     MP0, a
				;22		clr c
0004	340A	clr     C
				;23		Sub a, offset __initial_value_begin
0005	0A87	sub     a, 87H
				;24		snz c
0006	380A	snz     C
				;25		jmp startupend1
0007	280F	jmp     startupend1
				;26	L0004:
				;27		mov ra,a
				L0004:
0008	4088	mov     ra, a
				;28		CALL romdata_base1
0009	2010	call    romdata_base1
				;29		MOV iar,A
000A	0080	mov     [00H], a
				;30		dec mp
000B	1581	dec     MP0
				;31	  ;;	CLR WDT   ;;PD,TO flag will be clear. This line can be removed if a small number of global variables in C program are used.
				;32		deca ra
000C	5508	deca    ra
				;33		sz ra
000D	5088	sz      ra
				;34		jmp L0004 
000E	2808	jmp     L0004
				;35	startupend1:
				;36	  ;;	CLR WDT2  ;;PD,TO flag will be clear. This line can be removed if a small number of global variables in C program are used.
				;37	ROMBANK 0 @ROMDATA_BASE 
				;38	@ROMDATA_BASE .SECTION  inpage com_l 'CODE'
				;39	romdata_base1:
				;40		ADDM A,[06H]
				romdata_base1:
				@ROMDATA_BASE .SECTION 'CODE'
0010	0386	addm    a, PCL
				;41	
				;42	@HCCINIT   .SECTION  COM_L 'DATA'
				;43	__initial_value_begin:
				;44	@HCCINIT  .SECTION COM_E 'DATA'
				;45	__initial_value_end:
				;46	extern ra:byte
				;file E:\Doing\啟德電子\DriveHT1635Led\source\LedDisplay.c
				;1	//___________________________________________________________________
				;2	//___________________________________________________________________
				;3	//Copyright :    2015 by HOLTEK SEMICONDUCTOR INC
				;4	//File Name :    LedDisplay.c
				;5	//Targer :       
				;6	//MCU :          HT64F40
				;7	//Version :      V00
				;8	//Author :       ChenTing
				;9	//Date :         2015/05/18
				;10	//Description :  ledDisplay function
				;11	//History : 
				;12	//___________________________________________________________________
				;13	//___________________________________________________________________
				;14	#include "config.h"
				;15	
				;16	extern unsigned char displayState ;
				;17	
				;18	volatile unsigned char counter =0;
				@ROMDATA_BASE .SECTION 'CODE'
0011	0900	ret     a, 0H
0012	0000	nop
0013	0000	nop
				;19	
				;20	
				;21	const unsigned char	LedDisplayHell0Table[]={
0150	0900	ret     a, 0H
0151	0908	ret     a, 8H
0152	0920	ret     a, 20H
0153	09F8	ret     a, F8H
0154	093F	ret     a, 3FH
0155	0908	ret     a, 8H
0156	0921	ret     a, 21H
0157	0900	ret     a, 0H
0158	0901	ret     a, 1H
0159	0900	ret     a, 0H
015A	0901	ret     a, 1H
015B	0908	ret     a, 8H
015C	0921	ret     a, 21H
015D	09F8	ret     a, F8H
015E	093F	ret     a, 3FH
015F	0908	ret     a, 8H
0160	0920	ret     a, 20H
0161	0900	ret     a, 0H
0162	0900	ret     a, 0H
0163	0900	ret     a, 0H
0164	091F	ret     a, 1FH
0165	0980	ret     a, 80H
0166	0922	ret     a, 22H
0167	0980	ret     a, 80H
0168	0922	ret     a, 22H
0169	0980	ret     a, 80H
016A	0922	ret     a, 22H
016B	0980	ret     a, 80H
016C	0922	ret     a, 22H
016D	0900	ret     a, 0H
016E	0913	ret     a, 13H
016F	0900	ret     a, 0H
0170	0900	ret     a, 0H
0171	0900	ret     a, 0H
0172	0900	ret     a, 0H
0173	0908	ret     a, 8H
0174	0920	ret     a, 20H
0175	0908	ret     a, 8H
0176	0920	ret     a, 20H
0177	09F8	ret     a, F8H
0178	093F	ret     a, 3FH
0179	0900	ret     a, 0H
017A	0920	ret     a, 20H
017B	0900	ret     a, 0H
017C	0920	ret     a, 20H
017D	0900	ret     a, 0H
017E	0900	ret     a, 0H
017F	0900	ret     a, 0H
0180	0900	ret     a, 0H
0181	0900	ret     a, 0H
0182	0900	ret     a, 0H
0183	0908	ret     a, 8H
0184	0920	ret     a, 20H
0185	0908	ret     a, 8H
0186	0920	ret     a, 20H
0187	09F8	ret     a, F8H
0188	093F	ret     a, 3FH
0189	0900	ret     a, 0H
018A	0920	ret     a, 20H
018B	0900	ret     a, 0H
018C	0920	ret     a, 20H
018D	0900	ret     a, 0H
018E	0900	ret     a, 0H
018F	0900	ret     a, 0H
0190	0900	ret     a, 0H
0191	0900	ret     a, 0H
0192	0900	ret     a, 0H
0193	0900	ret     a, 0H
0194	091F	ret     a, 1FH
0195	0980	ret     a, 80H
0196	0920	ret     a, 20H
0197	0980	ret     a, 80H
0198	0920	ret     a, 20H
0199	0980	ret     a, 80H
019A	0920	ret     a, 20H
019B	0980	ret     a, 80H
019C	0920	ret     a, 20H
019D	0900	ret     a, 0H
019E	091F	ret     a, 1FH
019F	0900	ret     a, 0H
01A0	0900	ret     a, 0H
				;22	0x08,0x20,0xF8,0x3F,0x08,0x21,0x00,0x01,
				;23	0x00,0x01,0x08,0x21,0xF8,0x3F,0x08,0x20,/*"H",0*/
				;24	0x00,0x00,0x00,0x1F,0x80,0x22,0x80,0x22,
				;25	0x80,0x22,0x80,0x22,0x00,0x13,0x00,0x00,/*"e",1*/
				;26	0x00,0x00,0x08,0x20,0x08,0x20,0xF8,0x3F,
				;27	0x00,0x20,0x00,0x20,0x00,0x00,0x00,0x00,/*"l",2*/
				;28	0x00,0x00,0x08,0x20,0x08,0x20,0xF8,0x3F,
				;29	0x00,0x20,0x00,0x20,0x00,0x00,0x00,0x00,/*"l",3*/
				;30	0x00,0x00,0x00,0x1F,0x80,0x20,0x80,0x20,
				;31	0x80,0x20,0x80,0x20,0x00,0x1F,0x00,0x00/*"o",4*/
				;32	};
				;33	const unsigned char LedDisplayNormalTable[]={
				L0100:
0100	0386	addm    a, PCL
0101	0900	ret     a, 0H
0102	0900	ret     a, 0H
0103	0900	ret     a, 0H
0104	0900	ret     a, 0H
0105	0900	ret     a, 0H
0106	0900	ret     a, 0H
0107	09F8	ret     a, F8H
0108	090F	ret     a, FH
0109	0980	ret     a, 80H
010A	0900	ret     a, 0H
010B	0980	ret     a, 80H
010C	0900	ret     a, 0H
010D	0980	ret     a, 80H
010E	0900	ret     a, 0H
010F	09F8	ret     a, F8H
0110	090F	ret     a, FH
0111	0900	ret     a, 0H
0112	0900	ret     a, 0H
0113	09F0	ret     a, F0H
0114	0907	ret     a, 7H
0115	0908	ret     a, 8H
0116	0908	ret     a, 8H
0117	0908	ret     a, 8H
0118	0908	ret     a, 8H
0119	0908	ret     a, 8H
011A	0908	ret     a, 8H
011B	09F0	ret     a, F0H
011C	0907	ret     a, 7H
011D	0900	ret     a, 0H
011E	0900	ret     a, 0H
011F	09F8	ret     a, F8H
0120	090F	ret     a, FH
0121	0900	ret     a, 0H
0122	0908	ret     a, 8H
0123	0900	ret     a, 0H
0124	0908	ret     a, 8H
0125	0900	ret     a, 0H
0126	0908	ret     a, 8H
0127	0900	ret     a, 0H
0128	0908	ret     a, 8H
0129	0900	ret     a, 0H
012A	0900	ret     a, 0H
012B	0908	ret     a, 8H
012C	0900	ret     a, 0H
012D	0908	ret     a, 8H
012E	0900	ret     a, 0H
012F	09F8	ret     a, F8H
0130	090F	ret     a, FH
0131	0908	ret     a, 8H
0132	0900	ret     a, 0H
0133	0908	ret     a, 8H
0134	0900	ret     a, 0H
0135	0900	ret     a, 0H
0136	0900	ret     a, 0H
0137	09F8	ret     a, F8H
0138	090F	ret     a, FH
0139	0988	ret     a, 88H
013A	0908	ret     a, 8H
013B	0988	ret     a, 88H
013C	0908	ret     a, 8H
013D	0988	ret     a, 88H
013E	0908	ret     a, 8H
013F	0908	ret     a, 8H
0140	0908	ret     a, 8H
0141	0900	ret     a, 0H
0142	0900	ret     a, 0H
0143	09F8	ret     a, F8H
0144	090F	ret     a, FH
0145	0980	ret     a, 80H
0146	0900	ret     a, 0H
0147	0960	ret     a, 60H
0148	0903	ret     a, 3H
0149	0918	ret     a, 18H
014A	090C	ret     a, CH
014B	0900	ret     a, 0H
014C	0900	ret     a, 0H
014D	0900	ret     a, 0H
014E	0900	ret     a, 0H
014F	0900	ret     a, 0H
				;34	0X00,0X00,0X00,0X00,
				;35	0x00,0x00,0xF8,0x0F,0x80,0x00,0x80,0x00,
				;36	0x80,0x00,0xF8,0x0F,				/*"H",0*/
				;37	0x00,0x00,0xF0,0x07,0x08,0x08,0x08,0x08,
				;38	0x08,0x08,0xF0,0x07,				/*"O",1*/
				;39	0x00,0x00,0xF8,0x0F,0x00,0x08,0x00,0x08,
				;40	0x00,0x08,0x00,0x08,				/*"L",2*/
				;41	0x00,0x00,0x08,0x00,0x08,0x00,0xF8,0x0F,
				;42	0x08,0x00,0x08,0x00,				/*"T",3*/
				;43	0x00,0x00,0xF8,0x0F,0x88,0x08,0x88,0x08,
				;44	0x88,0x08,0x08,0x08,				/*"E",4*/
				;45	0x00,0x00,0xF8,0x0F,0x80,0x00,0x60,0x03,
				;46	0x18,0x0C,0x00,0x00,				/*"K",5*/
				;47	0X00,0X00,0X00,0X00
				;48	};
				;49	
				;50	
				;51	/*****************************
				;52	 *@描述 上電對led1 & led2 初始化
				;53	 *@參數 無
				;54	 *@返回 無
				;55	 ****************************/
				;56	void _init_led(void){
				;57		//init HT1635B 1 
				;58		iicSendCommand( SLAVEMCU1ADD , SYS_SET_COMMAND    , SYS_LED_DEFAULT1    );
				__init_led:
				__init_led:
00B5	0F03	mov     a, 3H
00B6	408F	mov     commandData, a
00B7	0F82	mov     a, 82H
00B8	408E	mov     command, a
00B9	0FD6	mov     a, D6H
00BA	209D	call    _iicSendCommand
				;59		iicSendCommand( SLAVEMCU1ADD , BLINK_FRQ_COMMAND  , BLINK_DEFAULT	    );
00BB	5F0F	clr     commandData
00BC	0F84	mov     a, 84H
00BD	408E	mov     command, a
00BE	0FD6	mov     a, D6H
00BF	209D	call    _iicSendCommand
				;60		iicSendCommand( SLAVEMCU1ADD , DRIVE_OUT_COMMAMND , DRIVE_TYPE_DEFAULT1 );
00C0	0F01	mov     a, 1H
00C1	408F	mov     commandData, a
00C2	0F88	mov     a, 88H
00C3	408E	mov     command, a
00C4	0FD6	mov     a, D6H
00C5	209D	call    _iicSendCommand
				;61		iicSendCommand( SLAVEMCU1ADD , CASCADE_COMMAND    , CASCADE_DEFAULT1    );
00C6	0F04	mov     a, 4H
00C7	408F	mov     commandData, a
00C8	0FA0	mov     a, A0H
00C9	408E	mov     command, a
00CA	0FD6	mov     a, D6H
00CB	209D	call    _iicSendCommand
				;62		iicSendCommand( SLAVEMCU1ADD , PWM_DUTY_COMMAND   , PWM_DUTY_DEFAULT1   );
00CC	0F0F	mov     a, FH
00CD	408F	mov     commandData, a
00CE	0FC0	mov     a, C0H
00CF	408E	mov     command, a
00D0	0FD6	mov     a, D6H
00D1	209D	call    _iicSendCommand
				;63		//init HT1635B 2
				;64		iicSendCommand( SLAVEMCU2ADD , SYS_SET_COMMAND    , SYS_LED_DEFAULT2    );
00D2	0F03	mov     a, 3H
00D3	408F	mov     commandData, a
00D4	0F82	mov     a, 82H
00D5	408E	mov     command, a
00D6	0FD4	mov     a, D4H
00D7	209D	call    _iicSendCommand
				;65		iicSendCommand( SLAVEMCU2ADD , BLINK_FRQ_COMMAND  , BLINK_DEFAULT		);
00D8	5F0F	clr     commandData
00D9	0F84	mov     a, 84H
00DA	408E	mov     command, a
00DB	0FD4	mov     a, D4H
00DC	209D	call    _iicSendCommand
				;66		iicSendCommand( SLAVEMCU2ADD , DRIVE_OUT_COMMAMND , DRIVE_TYPE_DEFAULT2 );
00DD	0F01	mov     a, 1H
00DE	408F	mov     commandData, a
00DF	0F88	mov     a, 88H
00E0	408E	mov     command, a
00E1	0FD4	mov     a, D4H
00E2	209D	call    _iicSendCommand
				;67		iicSendCommand( SLAVEMCU2ADD , CASCADE_COMMAND    , CASCADE_DEFAULT2	);
00E3	0F04	mov     a, 4H
00E4	408F	mov     commandData, a
00E5	0FA0	mov     a, A0H
00E6	408E	mov     command, a
00E7	0FD4	mov     a, D4H
00E8	209D	call    _iicSendCommand
				;68		iicSendCommand( SLAVEMCU2ADD , PWM_DUTY_COMMAND   , PWM_DUTY_DEFAULT2	);
00E9	0F0F	mov     a, FH
00EA	408F	mov     commandData, a
00EB	0FC0	mov     a, C0H
00EC	408E	mov     command, a
00ED	0FD4	mov     a, D4H
00EE	209D	call    _iicSendCommand
				;69		//power on Display hello
				;70		_updateDisplayHello();
00EF	21A1	call    __updateDisplayHello
				;71		displayState=displayState_Hello;	
00F0	5F01	clr     displayState[0]
00F1	0003	ret
				;72	}
				;73	/**************************
				;74	 *@描述 設定LED閃爍mode (利用MCU內部的Blink mode)
				;75	 *@參數 無
				;76	 *@返回 無
				;77	 *************************/
				;78	void _updateDisplayBlink(void){
				;79		_updateDisplayAll();	
				__updateDisplayBlink:
				__updateDisplayBlink:
00F2	2269	call    __updateDisplayAll
				;80		iicSendCommand( SLAVEMCU1ADD , BLINK_FRQ_COMMAND , BLINK_1HZ );
00F3	0F02	mov     a, 2H
00F4	408F	mov     commandData, a
00F5	0F84	mov     a, 84H
00F6	408E	mov     command, a
00F7	0FD6	mov     a, D6H
00F8	209D	call    _iicSendCommand
				;81		iicSendCommand( SLAVEMCU2ADD , BLINK_FRQ_COMMAND , BLINK_1HZ );
00F9	0F02	mov     a, 2H
00FA	408F	mov     commandData, a
00FB	0F84	mov     a, 84H
00FC	408E	mov     command, a
00FD	0FD4	mov     a, D4H
00FE	209D	call    _iicSendCommand
00FF	0003	ret
				;82	}
				;83	/***************************
				;84	 *@描述 顯示hello
				;85	 *@參數 無
				;86	 &@返回 無
				;87	 *************************/
				;88	void _updateDisplayHello(void){
				;89		iicSendCommand( SLAVEMCU1ADD , BLINK_FRQ_COMMAND  , BLINK_OFF);
				__updateDisplayHello:
				__updateDisplayHello:
01A1	5F0F	clr     commandData
01A2	0F84	mov     a, 84H
01A3	408E	mov     command, a
01A4	0FD6	mov     a, D6H
01A5	209D	call    _iicSendCommand
				;90		iicSendCommand( SLAVEMCU2ADD , BLINK_FRQ_COMMAND  , BLINK_OFF);
01A6	5F0F	clr     commandData
01A7	0F84	mov     a, 84H
01A8	408E	mov     command, a
01A9	0FD4	mov     a, D4H
01AA	209D	call    _iicSendCommand
				;91	//update HT1635B 1 data
				;92		iicStart();
01AB	2059	call    _iicStart
				;93		//發送HT1635B 1 IIC地址
				;94		iicWrite(SLAVEMCU1ADD);	
01AC	0FD6	mov     a, D6H
01AD	2085	call    _iicWrite
				;95		if (TestAck()==1){
01AE	206E	call    _TestAck
01AF	4088	mov     ra, a
01B0	5708	sdza    ra
01B1	29B4	jmp     _L2
				;96			iicStop();
				_L3:
01B2	2064	call    _iicStop
01B3	2A04	jmp     _L31
				;97			return;
				;98		}
				;99		//發送寫數據命令
				;100		iicWrite(SEND_DATA_COMMAND);
				_L2:
01B4	0F80	mov     a, 80H
01B5	2085	call    _iicWrite
				;101		if (TestAck()==1){
01B6	206E	call    _TestAck
01B7	4088	mov     ra, a
01B8	5708	sdza    ra
01B9	29BB	jmp     _LI1
01BA	29B2	jmp     _L3
				;102			iicStop();
				;103			return;
				;104		}
				;105		//發送寫入起始地址
				;106		iicWrite(0X00);				
				_LI1:
01BB	0F00	mov     a, 0H
01BC	2085	call    _iicWrite
				;107		if (TestAck()==1){
01BD	206E	call    _TestAck
01BE	4088	mov     ra, a
01BF	5708	sdza    ra
01C0	29C2	jmp     _LI2
01C1	29B2	jmp     _L3
				;108			iicStop();
				;109			return;
				;110		}
				;111		//循環寫入HT1635B 1的數據
				;112		for (counter=0; counter < 80; counter=counter+2){
				_LI2:
01C2	5F07	clr     counter[0]
				_L4:
01C3	0F4F	mov     a, 4FH
01C4	4207	sub     a, counter[0]
01C5	380A	snz     C
01C6	29D7	jmp     _L32
				_LI3:
01D4	0F02	mov     a, 2H
01D5	4387	addm    a, counter[0]
01D6	29C3	jmp     _L4
				;113			iicWrite(LedDisplayHell0Table[counter]);
01C7	0F50	mov     a, 50H
01C8	4307	add     a, counter[0]
01C9	0083	mov     MP1, a
01CA	0F80	mov     a, 80H
01CB	1F07	clr     TBLP
01CC	1387	adcm    a, TBLP
01CD	23A8	call    L03A8
01CE	2085	call    _iicWrite
				;114			if (TestAck()==1){
01CF	206E	call    _TestAck
01D0	4088	mov     ra, a
01D1	5708	sdza    ra
01D2	29D4	jmp     _LI3
01D3	29B2	jmp     _L3
				;115				iicStop();
				;116				return;
				;117			}
				;118		}
				;119		//HT1635B 1的數據寫入完成，停止IIC
				;120		iicStop();
				_L32:
01D7	2064	call    _iicStop
				;121	
				;122	//update HT1635B 2 data
				;123		iicStart();
01D8	2059	call    _iicStart
				;124		//發送HT1635B 2 IIC地址
				;125		iicWrite(SLAVEMCU2ADD);
01D9	0FD4	mov     a, D4H
01DA	2085	call    _iicWrite
				;126		if (TestAck()==1){
01DB	206E	call    _TestAck
01DC	4088	mov     ra, a
01DD	5708	sdza    ra
01DE	29E0	jmp     _LI4
01DF	29B2	jmp     _L3
				;127			iicStop();
				;128			return;
				;129		}
				;130		//發送寫數據命令
				;131		iicWrite(SEND_DATA_COMMAND);
				_LI4:
01E0	0F80	mov     a, 80H
01E1	2085	call    _iicWrite
				;132		if (TestAck()==1){
01E2	206E	call    _TestAck
01E3	4088	mov     ra, a
01E4	5708	sdza    ra
01E5	29E7	jmp     _LI5
01E6	29B2	jmp     _L3
				;133			iicStop();
				;134			return;
				;135		}
				;136		//發送寫入起始地址
				;137		iicWrite(0X00);
				_LI5:
01E7	0F00	mov     a, 0H
01E8	2085	call    _iicWrite
				;138		if (TestAck()==1){
01E9	206E	call    _TestAck
01EA	4088	mov     ra, a
01EB	5708	sdza    ra
01EC	29EE	jmp     _LI6
01ED	29B2	jmp     _L3
				;139			iicStop();
				;140			return;
				;141		}
				;142		//循環寫入HT1635B 2的數據
				;143		for (counter = 1; counter < 80; counter=counter+2){
				_LI6:
01EE	0F01	mov     a, 1H
01EF	4087	mov     counter[0], a
				_L6:
01F0	0F4F	mov     a, 4FH
01F1	4207	sub     a, counter[0]
01F2	380A	snz     C
01F3	29B2	jmp     _L3
				_LI7:
0201	0F02	mov     a, 2H
0202	4387	addm    a, counter[0]
0203	29F0	jmp     _L6
				_L31:
0204	0003	ret
				;144			iicWrite(LedDisplayHell0Table[counter]);
01F4	0F50	mov     a, 50H
01F5	4307	add     a, counter[0]
01F6	0083	mov     MP1, a
01F7	0F80	mov     a, 80H
01F8	1F07	clr     TBLP
01F9	1387	adcm    a, TBLP
01FA	23A8	call    L03A8
01FB	2085	call    _iicWrite
				;145			if (TestAck()==1){
01FC	206E	call    _TestAck
01FD	4088	mov     ra, a
01FE	5708	sdza    ra
01FF	2A01	jmp     _LI7
0200	29B2	jmp     _L3
				;146				iicStop();
				;147				return;
				;148			}
				;149		}
				;150		//HT1635B 2的數據寫入完成，停止IIC
				;151		iicStop();	
				;152	}
				;153	/***********************
				;154	顯示HOLTEK
				;155	
				;156	**********/
				;157	void _updateDisplayNormal(void){
				;158		iicSendCommand( SLAVEMCU1ADD , BLINK_FRQ_COMMAND  , BLINK_OFF);
				__updateDisplayNormal:
				__updateDisplayNormal:
0205	5F0F	clr     commandData
0206	0F84	mov     a, 84H
0207	408E	mov     command, a
0208	0FD6	mov     a, D6H
0209	209D	call    _iicSendCommand
				;159		iicSendCommand( SLAVEMCU2ADD , BLINK_FRQ_COMMAND  , BLINK_OFF);
020A	5F0F	clr     commandData
020B	0F84	mov     a, 84H
020C	408E	mov     command, a
020D	0FD4	mov     a, D4H
020E	209D	call    _iicSendCommand
				;160	//update HT1635B 1 data
				;161		iicStart();
020F	2059	call    _iicStart
				;162		//發送HT1635B 1 IIC地址
				;163		iicWrite(SLAVEMCU1ADD);
0210	0FD6	mov     a, D6H
0211	2085	call    _iicWrite
				;164		if (TestAck()==1){
0212	206E	call    _TestAck
0213	4088	mov     ra, a
0214	5708	sdza    ra
0215	2A18	jmp     _L35
				;165			iicStop();
				_L37:
0216	2064	call    _iicStop
				;166			return;
0217	2A68	jmp     _L34
				;167		}
				;168		//發送寫數據命令	
				;169		iicWrite(SEND_DATA_COMMAND);
				_L35:
0218	0F80	mov     a, 80H
0219	2085	call    _iicWrite
				;170		if (TestAck()==1){
021A	206E	call    _TestAck
021B	4088	mov     ra, a
021C	5708	sdza    ra
021D	2A1F	jmp     _LI8
021E	2A16	jmp     _L37
				;171			iicStop();
				;172			return;
				;173		}
				;174		//發送寫入起始地址
				;175		iicWrite(0X00);
				_LI8:
021F	0F00	mov     a, 0H
0220	2085	call    _iicWrite
				;176		if (TestAck()==1){
0221	206E	call    _TestAck
0222	4088	mov     ra, a
0223	5708	sdza    ra
0224	2A26	jmp     _LI9
0225	2A16	jmp     _L37
				;177			iicStop();
				;178			return;
				;179		}
				;180		//循環寫入HT1635B 1的數據
				;181		for (counter=0; counter < 80; counter=counter+2){
				_LI9:
0226	5F07	clr     counter[0]
				_L38:
0227	0F4F	mov     a, 4FH
0228	4207	sub     a, counter[0]
0229	380A	snz     C
022A	2A3B	jmp     _L63
				_LI10:
0238	0F02	mov     a, 2H
0239	4387	addm    a, counter[0]
023A	2A27	jmp     _L38
				;182			iicWrite(LedDisplayNormalTable[counter]);
022B	0F00	mov     a, 0H
022C	4307	add     a, counter[0]
022D	0083	mov     MP1, a
022E	0F80	mov     a, 80H
022F	1F07	clr     TBLP
0230	1387	adcm    a, TBLP
0231	23A8	call    L03A8
0232	2085	call    _iicWrite
				;183			if (TestAck()==1){
0233	206E	call    _TestAck
0234	4088	mov     ra, a
0235	5708	sdza    ra
0236	2A38	jmp     _LI10
0237	2A16	jmp     _L37
				;184				iicStop();
				;185				return;
				;186			}
				;187		}
				;188		//HT1635B 1的數據寫入完成，停止IIC
				;189		iicStop();
				_L63:
023B	2064	call    _iicStop
				;190	
				;191	//update HT1635B 2 data
				;192		iicStart();
023C	2059	call    _iicStart
				;193		//發送HT1635B 2 IIC地址
				;194		iicWrite(SLAVEMCU2ADD);
023D	0FD4	mov     a, D4H
023E	2085	call    _iicWrite
				;195		if (TestAck()==1){
023F	206E	call    _TestAck
0240	4088	mov     ra, a
0241	5708	sdza    ra
0242	2A44	jmp     _LI11
0243	2A16	jmp     _L37
				;196			iicStop();
				;197			return;
				;198		}
				;199		//發送寫數據命令
				;200		iicWrite(SEND_DATA_COMMAND);
				_LI11:
0244	0F80	mov     a, 80H
0245	2085	call    _iicWrite
				;201		if (TestAck()==1){
0246	206E	call    _TestAck
0247	4088	mov     ra, a
0248	5708	sdza    ra
0249	2A4B	jmp     _LI12
024A	2A16	jmp     _L37
				;202			iicStop();
				;203			return;
				;204		}
				;205		//發送寫入起始地址
				;206		iicWrite(0X00);
				_LI12:
024B	0F00	mov     a, 0H
024C	2085	call    _iicWrite
				;207		if (TestAck()==1){
024D	206E	call    _TestAck
024E	4088	mov     ra, a
024F	5708	sdza    ra
0250	2A52	jmp     _LI13
0251	2A16	jmp     _L37
				;208			iicStop();
				;209			return;
				;210		}
				;211		//循環寫入HT1635B 2的數據
				;212		for (counter = 1; counter < 80; counter=counter+2){
				_LI13:
0252	0F01	mov     a, 1H
0253	4087	mov     counter[0], a
				_L40:
0254	0F4F	mov     a, 4FH
0255	4207	sub     a, counter[0]
0256	380A	snz     C
0257	2A68	jmp     _L34
				_LI14:
0265	0F02	mov     a, 2H
0266	4387	addm    a, counter[0]
0267	2A54	jmp     _L40
				_L34:
0268	0003	ret
				;213			iicWrite(LedDisplayNormalTable[counter]);
0258	0F00	mov     a, 0H
0259	4307	add     a, counter[0]
025A	0083	mov     MP1, a
025B	0F80	mov     a, 80H
025C	1F07	clr     TBLP
025D	1387	adcm    a, TBLP
025E	23A8	call    L03A8
025F	2085	call    _iicWrite
				;214			if (TestAck()==1){
0260	206E	call    _TestAck
0261	4088	mov     ra, a
0262	5708	sdza    ra
0263	2A65	jmp     _LI14
0264	2A16	jmp     _L37
				;215				iicStop();
				;216				return;
				;217			}
				;218		}
				;219	}
				;220	/***********************
				;221	全亮
				;222	**********/
				;223	void _updateDisplayAll(void){
				;224		iicSendCommand( SLAVEMCU1ADD , BLINK_FRQ_COMMAND  , BLINK_OFF);
				__updateDisplayAll:
				__updateDisplayAll:
0269	5F0F	clr     commandData
026A	0F84	mov     a, 84H
026B	408E	mov     command, a
026C	0FD6	mov     a, D6H
026D	209D	call    _iicSendCommand
				;225		iicSendCommand( SLAVEMCU2ADD , BLINK_FRQ_COMMAND  , BLINK_OFF);
026E	5F0F	clr     commandData
026F	0F84	mov     a, 84H
0270	408E	mov     command, a
0271	0FD4	mov     a, D4H
0272	209D	call    _iicSendCommand
				;226	//Display all HT1635B 1
				;227		iicStart();
0273	2059	call    _iicStart
				;228		//發送HT1635B 1 IIC地址
				;229		iicWrite(SLAVEMCU1ADD);
0274	0FD6	mov     a, D6H
0275	2085	call    _iicWrite
				;230		if (TestAck()==1){
0276	206E	call    _TestAck
0277	4088	mov     ra, a
0278	5708	sdza    ra
0279	2A7C	jmp     _L65
				;231			iicStop();
				_L66:
027A	2064	call    _iicStop
027B	2ABC	jmp     _L93
				;232			return;
				;233		}
				;234		//發送寫數據命令
				;235		iicWrite(SEND_DATA_COMMAND);
				_L65:
027C	0F80	mov     a, 80H
027D	2085	call    _iicWrite
				;236		if (TestAck()==1){
027E	206E	call    _TestAck
027F	4088	mov     ra, a
0280	5708	sdza    ra
0281	2A83	jmp     _LI15
0282	2A7A	jmp     _L66
				;237			iicStop();
				;238			return;
				;239		}
				;240		//發送寫入起始地址
				;241		iicWrite(0X00);
				_LI15:
0283	0F00	mov     a, 0H
0284	2085	call    _iicWrite
				;242		if (TestAck()==1){
0285	206E	call    _TestAck
0286	4088	mov     ra, a
0287	5708	sdza    ra
0288	2A8A	jmp     _LI16
0289	2A7A	jmp     _L66
				;243			iicStop();
				;244			return;
				;245		}
				;246		//循環寫入HT1635B 1的數據
				;247		for (counter = 0; counter < 44; counter++){
				_LI16:
028A	5F07	clr     counter[0]
				_L67:
028B	0F2B	mov     a, 2BH
028C	4207	sub     a, counter[0]
028D	380A	snz     C
028E	2A98	jmp     _L94
				_LI17:
0296	5487	inc     counter[0]
0297	2A8B	jmp     _L67
				;248			iicWrite(0Xff);
028F	0FFF	mov     a, FFH
0290	2085	call    _iicWrite
				;249			if (TestAck()==1){
0291	206E	call    _TestAck
0292	4088	mov     ra, a
0293	5708	sdza    ra
0294	2A96	jmp     _LI17
0295	2A7A	jmp     _L66
				;250				iicStop();
				;251				return;
				;252			}
				;253		}
				;254		//Display all HT1635B 2
				;255		iicStart();
				_L94:
0298	2059	call    _iicStart
				;256		//發送HT1635B 2 IIC地址
				;257		iicWrite(SLAVEMCU2ADD);
0299	0FD4	mov     a, D4H
029A	2085	call    _iicWrite
				;258		if (TestAck()==1){
029B	206E	call    _TestAck
029C	4088	mov     ra, a
029D	5708	sdza    ra
029E	2AA0	jmp     _LI18
029F	2A7A	jmp     _L66
				;259			iicStop();
				;260			return;
				;261		}
				;262		//發送寫數據命令
				;263		iicWrite(SEND_DATA_COMMAND);
				_LI18:
02A0	0F80	mov     a, 80H
02A1	2085	call    _iicWrite
				;264		if (TestAck()==1){
02A2	206E	call    _TestAck
02A3	4088	mov     ra, a
02A4	5708	sdza    ra
02A5	2AA7	jmp     _LI19
02A6	2A7A	jmp     _L66
				;265			iicStop();
				;266			return;
				;267		}
				;268		//發送寫入起始地址
				;269		iicWrite(0X00);
				_LI19:
02A7	0F00	mov     a, 0H
02A8	2085	call    _iicWrite
				;270		if (TestAck()==1){
02A9	206E	call    _TestAck
02AA	4088	mov     ra, a
02AB	5708	sdza    ra
02AC	2AAE	jmp     _LI20
02AD	2A7A	jmp     _L66
				;271			iicStop();
				;272			return;
				;273		}
				;274		//循環寫入HT1635B 2的數據
				;275		for (counter = 0; counter < 44; counter++){
				_LI20:
02AE	5F07	clr     counter[0]
				_L69:
02AF	0F2B	mov     a, 2BH
02B0	4207	sub     a, counter[0]
02B1	380A	snz     C
02B2	2A7A	jmp     _L66
				_LI21:
02BA	5487	inc     counter[0]
02BB	2AAF	jmp     _L69
				_L93:
02BC	0003	ret
				;276			iicWrite(0Xff);
02B3	0FFF	mov     a, FFH
02B4	2085	call    _iicWrite
				;277			if (TestAck()==1){
02B5	206E	call    _TestAck
02B6	4088	mov     ra, a
02B7	5708	sdza    ra
02B8	2ABA	jmp     _LI21
02B9	2A7A	jmp     _L66
				;278				iicStop();
				;279				return;
				;280			}
				;281		}
				;282		iicStop();
				;283	}
				;284	/***********************
				;285	全滅
				;286	
				;287	**********/
				;288	void _updateDisplayoff(void){
				;289		iicSendCommand( SLAVEMCU1ADD , BLINK_FRQ_COMMAND  , BLINK_OFF);
				__updateDisplayoff:
				__updateDisplayoff:
02BD	5F0F	clr     commandData
02BE	0F84	mov     a, 84H
02BF	408E	mov     command, a
02C0	0FD6	mov     a, D6H
02C1	209D	call    _iicSendCommand
				;290		iicSendCommand( SLAVEMCU2ADD , BLINK_FRQ_COMMAND  , BLINK_OFF);
02C2	5F0F	clr     commandData
02C3	0F84	mov     a, 84H
02C4	408E	mov     command, a
02C5	0FD4	mov     a, D4H
02C6	209D	call    _iicSendCommand
				;291		//Display off HT1635B 1
				;292		iicStart();
02C7	2059	call    _iicStart
				;293		//發送HT1635B 1 IIC地址
				;294		iicWrite(SLAVEMCU1ADD);
02C8	0FD6	mov     a, D6H
02C9	2085	call    _iicWrite
				;295		if (TestAck()==1){
02CA	206E	call    _TestAck
02CB	4088	mov     ra, a
02CC	5708	sdza    ra
02CD	2AD0	jmp     _L97
				;296			iicStop();
				_L99:
02CE	2064	call    _iicStop
				;297			return;
02CF	2B10	jmp     _L96
				;298		}
				;299		//發送寫數據命令
				;300		iicWrite(SEND_DATA_COMMAND);
				_L97:
02D0	0F80	mov     a, 80H
02D1	2085	call    _iicWrite
				;301		if (TestAck()==1){
02D2	206E	call    _TestAck
02D3	4088	mov     ra, a
02D4	5708	sdza    ra
02D5	2AD7	jmp     _LI22
02D6	2ACE	jmp     _L99
				;302			iicStop();
				;303			return;
				;304		}
				;305		//發送寫入起始地址
				;306		iicWrite(0X00);
				_LI22:
02D7	0F00	mov     a, 0H
02D8	2085	call    _iicWrite
				;307		if (TestAck()==1){
02D9	206E	call    _TestAck
02DA	4088	mov     ra, a
02DB	5708	sdza    ra
02DC	2ADE	jmp     _LI23
02DD	2ACE	jmp     _L99
				;308			iicStop();
				;309			return;
				;310		}
				;311		//循環寫入HT1635B 1的數據
				;312		for (counter = 0; counter < 44; counter++){
				_LI23:
02DE	5F07	clr     counter[0]
				_L100:
02DF	0F2B	mov     a, 2BH
02E0	4207	sub     a, counter[0]
02E1	380A	snz     C
02E2	2AEC	jmp     _L125
				_LI24:
02EA	5487	inc     counter[0]
02EB	2ADF	jmp     _L100
				;313			iicWrite(0X00);
02E3	0F00	mov     a, 0H
02E4	2085	call    _iicWrite
				;314			if (TestAck()==1){
02E5	206E	call    _TestAck
02E6	4088	mov     ra, a
02E7	5708	sdza    ra
02E8	2AEA	jmp     _LI24
02E9	2ACE	jmp     _L99
				;315				iicStop();
				;316				return;
				;317			}
				;318		}
				;319		//Display off HT1635B 2
				;320		iicStart();
				_L125:
02EC	2059	call    _iicStart
				;321		//發送HT1635B 2 IIC地址
				;322		iicWrite(SLAVEMCU2ADD);
02ED	0FD4	mov     a, D4H
02EE	2085	call    _iicWrite
				;323		if (TestAck()==1){
02EF	206E	call    _TestAck
02F0	4088	mov     ra, a
02F1	5708	sdza    ra
02F2	2AF4	jmp     _LI25
02F3	2ACE	jmp     _L99
				;324			iicStop();
				;325			return;
				;326		}
				;327		//發送寫數據命令
				;328		iicWrite(SEND_DATA_COMMAND);
				_LI25:
02F4	0F80	mov     a, 80H
02F5	2085	call    _iicWrite
				;329		if (TestAck()==1){
02F6	206E	call    _TestAck
02F7	4088	mov     ra, a
02F8	5708	sdza    ra
02F9	2AFB	jmp     _LI26
02FA	2ACE	jmp     _L99
				;330			iicStop();
				;331			return;
				;332		}
				;333		//發送寫入起始地址	
				;334		iicWrite(0X00);
				_LI26:
02FB	0F00	mov     a, 0H
02FC	2085	call    _iicWrite
				;335		if (TestAck()==1){
02FD	206E	call    _TestAck
02FE	4088	mov     ra, a
02FF	5708	sdza    ra
0300	2B02	jmp     _LI27
0301	2ACE	jmp     _L99
				;336			iicStop();
				;337			return;
				;338		}
				;339		//循環寫入HT1635B 2的數據
				;340		for (counter = 0; counter < 44; counter++){
				_LI27:
0302	5F07	clr     counter[0]
				_L102:
0303	0F2B	mov     a, 2BH
0304	4207	sub     a, counter[0]
0305	380A	snz     C
0306	2B10	jmp     _L96
				_LI28:
030E	5487	inc     counter[0]
030F	2B03	jmp     _L102
				_L96:
0310	0003	ret
				;341			iicWrite(0X00);
0307	0F00	mov     a, 0H
0308	2085	call    _iicWrite
				;342			if (TestAck()==1){
0309	206E	call    _TestAck
030A	4088	mov     ra, a
030B	5708	sdza    ra
030C	2B0E	jmp     _LI28
030D	2ACE	jmp     _L99
				;343				iicStop();
				;344				return;
				;345			}
				;346		}
				;347	}
				;348	
				;349	
				;350	
				;file E:\Doing\啟德電子\DriveHT1635Led\source\sysinit.c
				;1	//___________________________________________________________________
				;2	//___________________________________________________________________
				;3	//Copyright :    2015 by HOLTEK SEMICONDUCTOR INC
				;4	//File Name :    sysinit.c
				;5	//Targer :       
				;6	//MCU :          HT68F40
				;7	//Version :      V00
				;8	//Author :       ChenTing
				;9	//Date :         2015/05/18
				;10	//Description :  config system
				;11	//History : 
				;12	//___________________________________________________________________
				;13	//___________________________________________________________________
				;14	#include "config.h"
				;15	
				;16	
				;17	
				;18	
				;19	volatile unsigned char counter10ms;
				;20	volatile unsigned int  counter3s;
				;21	extern unsigned char  keyCount;
				;22	
				;23	void _clearRam(void){
				;24		_bp = 0x00;
				__clearRam:
				__clearRam:
0311	1F04	clr     BP
				;25		_mp1 = 0x80;
0312	0F80	mov     a, 80H
0313	0083	mov     MP1, a
				;26			for(_tblp = 0x00;_tblp < 128;_tblp++)
0314	1F07	clr     TBLP
				_L2:
0315	3F87	sz      TBLP.7
0316	2B1B	jmp     _L7
0319	1487	inc     TBLP
031A	2B15	jmp     _L2
				;27			{
				;28				 _iar1 = 0;
0317	1F02	clr     __iar1[0]
				;29				  _mp1++;
0318	1483	inc     MP1
				;30			}
				;31		_bp = 0x01;
				_L7:
031B	0F01	mov     a, 1H
031C	0084	mov     BP, a
				;32		_mp1 = 0x80;		
031D	0F80	mov     a, 80H
031E	0083	mov     MP1, a
				;33			for(_tblp = 0x00;_tblp < 64;_tblp++)
031F	1F07	clr     TBLP
				_L4:
0320	0F3F	mov     a, 3FH
0321	0207	sub     a, TBLP
0322	380A	snz     C
0323	2B28	jmp     _L8
0326	1487	inc     TBLP
0327	2B20	jmp     _L4
				;34			{
				;35				 _iar1 = 0;
0324	1F02	clr     __iar1[0]
				;36				  _mp1++;
0325	1483	inc     MP1
				;37			}
				;38		_bp=0x00;
				_L8:
0328	1F04	clr     BP
0329	0003	ret
				;39		}
				;40	
				;41	void _reset_init(void){
				;42		_sysinit();
				;43		}
				;44	
				;45	//
				;46	void _sysinit(void){
				;47	//IO
				;48		_pac=0;
				__sysinit:
				__sysinit:
032A	1F1B	clr     PAC
				;49		_pa=0;
032B	1F1A	clr     PA
				;50		_papu=0xff;
032C	1F99	set     PAPU
				;51		_pawu=1;
032D	0F01	mov     a, 1H
032E	0098	mov     PAWU, a
				;52		
				;53		_pbc=0;
032F	1F1E	clr     PBC
				;54		_pb=0;
0330	1F1D	clr     PB
				;55		_pbpu=0xff;
0331	1F9C	set     PBPU
				;56		
				;57		_pcc=0;
0332	1F21	clr     PCC
				;58		_pc=0;
0333	1F20	clr     PC
				;59		_pcpu=0xff;
0334	1F9F	set     PCPU
				;60		
				;61		_pdc=0;
0335	1F24	clr     PDC
				;62		_pd=0;
0336	1F23	clr     PD
				;63		_pdpu=0xff;
0337	1FA2	set     PDPU
				;64		
				;65		_pec=0;
0338	1F27	clr     PEC
				;66		_pe=0;
0339	1F26	clr     PE
				;67		_pepu=0xff;
033A	1FA5	set     PEPU
				;68		
				;69		_pfc=0;
033B	1F2A	clr     PFC
				;70		_pf=0;
033C	1F29	clr     PF
				;71		_pfpu=0xff;	
033D	1FA8	set     PFPU
				;72		
				;73	//cp
				;74		_cp0c=0;
033E	1F34	clr     CP0C
				;75		_cp1c=0;	
033F	1F35	clr     CP1C
				;76	//Timer
				;77		_tm0c0=0x00;
0340	1F3A	clr     TM0C0
				;78		_tm0c1=0xc1;
0341	0FC1	mov     a, C1H
0342	00BB	mov     TM0C1, a
				;79		_tm0al=0xe8;
0343	0FE8	mov     a, E8H
0344	00BE	mov     TM0AL, a
				;80		_tm0ah=0x03;
0345	0F03	mov     a, 3H
0346	00BF	mov     TM0AH, a
				;81		_mf0f=0;
0347	3691	clr     MF0F
				;82		_mf0e=1;
0348	3091	set     MF0E
				;83		_t0ae=1;
0349	3094	set     T0AE
				;84		_t0af=0;
034A	3694	clr     T0AF
				;85		_emi=1;
034B	3010	set     EMI
				;86		_t0on=1;
034C	31BA	set     T0ON
				;87	//Ram
				;88		counter10ms=10;
034D	0F0A	mov     a, AH
034E	4084	mov     counter10ms[0], a
				;89		counter3s=300;
034F	0F2C	mov     a, 2CH
0350	4082	mov     counter3s[0], a
0351	0F01	mov     a, 1H
0352	4083	mov     counter3s[1], a
				;90		keyCount=0;
0353	5F05	clr     keyCount[0]
				;91		flag_byte0.byte=0;
0354	5F06	clr     flag_byte0[0]
0355	0003	ret
				;92		}
				;93		
				;94	DEFINE_ISR(timer0, 0x14){
				@timer0_code .SECTION 'CODE'
0014	4089	mov     r114, a
0015	0704	mov     a, BP
0016	408A	mov     r214, a
0017	2B56	jmp     _timer0
				_timer0:
				_timer0:
0356	070A	mov     a, STATUS
0357	408B	mov     r314, a
				;95	//	flag_1ms=1;
				;96		counter10ms--;
0358	5784	sdz     counter10ms[0]
0359	2B6A	jmp     _L13
				;97		if(counter10ms==0){
				;98			flag_10ms=1;
035A	7106	set     flag_byte0[0].2
				;99			counter10ms=10;	
035B	0F0A	mov     a, AH
035C	4084	mov     counter10ms[0], a
				;100			counter3s--;
035D	0FFF	mov     a, FFH
035E	4382	addm    a, counter3s[0]
035F	0FFF	mov     a, FFH
0360	5383	adcm    a, counter3s[1]
				;101			if(counter3s==0){
0361	4702	mov     a, counter3s[0]
0362	4503	or      a, counter3s[1]
0363	390A	snz     Z
0364	2B6A	jmp     _L13
				;102				flag_3s=1;
0365	7086	set     flag_byte0[0].1
				;103				counter3s=300;
0366	0F2C	mov     a, 2CH
0367	4082	mov     counter3s[0], a
0368	0F01	mov     a, 1H
0369	4083	mov     counter3s[1], a
				;104			}
				;105		}	
				;106		_t0af=0;
				_L13:
036A	3694	clr     T0AF
036B	470A	mov     a, r214
036C	0084	mov     BP, a
036D	470B	mov     a, r314
036E	008A	mov     STATUS, a
036F	4709	mov     a, r114
0370	0004	reti
				;107	}
				;file E:\Doing\啟德電子\DriveHT1635Led\source\IIC.c
				;1	//___________________________________________________________________
				;2	//___________________________________________________________________
				;3	//Copyright :    2015 by HOLTEK SEMICONDUCTOR INC
				;4	//File Name :    IIC.C
				;5	//Targer :       
				;6	//MCU :          HT64F50
				;7	//Version :      V00
				;8	//Author :       ChenTing
				;9	//Date :         2015/05/18
				;10	//Description :  IIC function
				;11	//History : 
				;12	//___________________________________________________________________
				;13	//___________________________________________________________________
				;14	#include "config.h"
				;15	
				;16	
				;17	
				;18	/**********************************
				;19	IIC設置命令發送程序
				;20	**********************************/
				;21	void iicSendCommand(unsigned char address, unsigned char command,unsigned char commandData)
				;22	{
				_iicSendCommand:
				_iicSendCommand:
009D	4090	mov     address[0], a
				;23		iicStart();
009E	2059	call    _iicStart
				;24		iicWrite(address);
009F	4710	mov     a, address[0]
00A0	2085	call    _iicWrite
				;25		if (TestAck()==1){
00A1	206E	call    _TestAck
00A2	4088	mov     ra, a
00A3	5708	sdza    ra
00A4	28A7	jmp     L00A7
				;26			iicStop();
				L00A5:
00A5	2064	call    _iicStop
00A6	28B4	jmp     L00B4
				;27			return;
				;28		}
				;29		iicWrite(command);
				L00A7:
00A7	470E	mov     a, command[0]
00A8	2085	call    _iicWrite
				;30		if (TestAck()==1){
00A9	206E	call    _TestAck
00AA	4088	mov     ra, a
00AB	5708	sdza    ra
00AC	28AE	jmp     L00AE
00AD	28A5	jmp     L00A5
				;31			iicStop();
				;32			return;
				;33		}
				;34		iicWrite(commandData);
				L00AE:
00AE	470F	mov     a, commandData[0]
00AF	4088	mov     ra, a
00B0	4708	mov     a, ra
00B1	2085	call    _iicWrite
				;35		if (TestAck()==1){
00B2	206E	call    _TestAck
00B3	28A5	jmp     L00A5
				L00B4:
00B4	0003	ret
				;36			iicStop();
				;37			return;
				;38		}
				;39		iicStop();
				;40	}
				;41	
				;42	/**********************************
				;43	I2C啟動信號
				;44	**********************************/
				;45	void iicStart(void)
				;46	{
				;47		SDAC=0;//設定SDA腳為輸出
				_iicStart:
				_iicStart:
0059	371B	clr     PAC6
				;48		SCLC=0;//設定SCL腳為輸出
005A	379B	clr     PAC7
				;49		SDA=1;_delay();
005B	331A	set     PA6
005C	2053	call    __delay
				;50		SCL=1;_delay();	//SCL=1 & SDA=1
005D	339A	set     PA7
005E	2053	call    __delay
				;51		SDA=0;_delay();	//SCL=1 & SDA=0 IIC Start flag	
005F	371A	clr     PA6
0060	2053	call    __delay
				;52		SCL=0;_delay();	//SCL=0		
0061	379A	clr     PA7
0062	2053	call    __delay
0063	0003	ret
				;53	}
				;54	
				;55	/**********************************
				;56	I2C停止信號
				;57	**********************************/
				;58	void iicStop(void)
				;59	{
				;60		SDAC=0;//設定SDA腳為輸出
				_iicStop:
				_iicStop:
0064	371B	clr     PAC6
				;61		SDA=0;_delay();//SDA=0
0065	371A	clr     PA6
0066	2053	call    __delay
				;62		SCL=1;_delay();//SCL=1
0067	339A	set     PA7
0068	2053	call    __delay
				;63		SDA=1;_delay();//SDA=1
0069	331A	set     PA6
006A	2053	call    __delay
				;64		SCL=0;_delay();//SCL=0	
006B	379A	clr     PA7
006C	2053	call    __delay
006D	0003	ret
				;65	}
				;66	//**********************************
				;67	//ACK(0)信號信號，通知從幾已讀取資料
				;68	//或后面還有資料
				;69	//**********************************
				;70	void Ack(void)
				;71	{
				;72		SDAC=0;//設定SDA腳為輸出
				;73		SDA=0;_delay();//SDA=0
				;74		SCL=1;_delay();//SCL=1
				;75		SCL=0;_delay();//SCL=0
				;76		SDA=1;_delay();//SDA=1
				;77	}
				;78	//**********************************
				;79	//NoAck(1)信號信號，通知從幾無資料讀取
				;80	//**********************************
				;81	void NoAck(void)
				;82	{
				;83		SDAC=0;//設定SDA腳為輸出
				;84		SDA=1;_delay();//SDA=1
				;85		SCL=1;_delay();//SCL=1
				;86		SCL=0;_delay();//SCL=0
				;87	}
				;88	//**********************************
				;89	//主機檢查從幾回傳的ACK信號
				;90	//0為ACK完成動作，1為未完成動作
				;91	//**********************************
				;92	unsigned char TestAck(void)
				;93	{	
				;94		volatile unsigned char ErrTime=0;//
				_TestAck:
				_TestAck:
006E	5F0C	clr     ErrTime[0]
				;95		SDAC=1;_delay();	//設定SDA腳為輸入
006F	331B	set     PAC6
0070	2053	call    __delay
				;96		SCL =1;_delay();	//SCL=1
0071	339A	set     PA7
0072	2053	call    __delay
				;97		while(SDA==1){
				_L7:
0073	071A	mov     a, PA
0074	0E40	and     a, 40H
0075	408D	mov     Data, a
0076	508D	sz      Data
0077	2879	jmp     _LI1
0078	2881	jmp     _L12
				;98			ErrTime++;
				_LI1:
0079	548C	inc     ErrTime[0]
				;99			if (ErrTime>250){
007A	0FFA	mov     a, FAH
007B	420C	sub     a, ErrTime[0]
007C	3C0A	sz      C
007D	2873	jmp     _L7
				;100				return 1;
007E	0F01	mov     a, 1H
007F	408D	mov     Data, a
0080	2883	jmp     _L8
				;101			}
				;102		}
				;103		SCL=0;_delay();
				_L12:
0081	379A	clr     PA7
0082	2053	call    __delay
				;104		return 0;
				;105	}
				_L8:
0083	470D	mov     a, Data
0084	0003	ret
				;106	//**********************************
				;107	//主機將資料以串列方式發射出去
				;108	//**********************************
				;109	void iicWrite(unsigned char Data)
				;110	{
				_iicWrite:
				_iicWrite:
0085	408D	mov     Data[0], a
				;111		volatile unsigned char count=8;
0086	0F08	mov     a, 8H
0087	408C	mov     count[0], a
				;112		SDAC=0;//設定SDA腳為輸出
0088	371B	clr     PAC6
				;113		while(count--)
0089	2896	jmp     L0096
				L0096:
0096	470C	mov     a, count[0]
0097	4088	mov     ra, a
0098	5508	deca    ra
0099	408C	mov     count[0], a
009A	5088	sz      ra
009B	288A	jmp     L008A
009C	0003	ret
				;114		{
				;115	//		SDA=(Data & 0x80);_delay();//取出資料的bit7送到SDA腳	
				;116	//		SCL=1;_delay();//送出i2c時鐘脈沖
				;117	//		SCL=0;_delay();
				;118	//		Data=Data<<1;	//資料左移一位
				;119	
				;120			if((Data & 0x80)==0){
				L008A:
008A	7F8D	sz      Data[0].7
008B	288E	jmp     L008E
				;121				SDA=0;
008C	371A	clr     PA6
008D	288F	jmp     L008F
				;122			}
				;123			else{
				;124				SDA=1;
				L008E:
008E	331A	set     PA6
				;125			}
				;126			_delay();
				L008F:
008F	2053	call    __delay
				;127			SCL=1;_delay();//送出i2c時鐘脈沖
0090	339A	set     PA7
0091	2053	call    __delay
				;128			SCL=0;_delay();
0092	379A	clr     PA7
0093	2053	call    __delay
				;129			Data=Data<<1;	//資料左移一位		
0094	470D	mov     a, Data[0]
0095	438D	addm    a, Data[0]
				;130	
				;131		}
				;132	}
				;133	//**********************************
				;134	//主機讀取資料
				;135	//**********************************
				;136	unsigned char iicRead(void)
				;137	{
				;138		volatile unsigned char count=8,Data=0;
				;139		SDAC=1;//設定SDA腳為輸入
				;140		while(count--)
				;141		{
				;142			SCL=1;_delay();
				;143			Data=Data<<1;//資料左移一位
				;144			Data=Data|((unsigned char)(SDA));//讀取串bit與Data合并
				;145			SCL=0;
				;146		}	
				;147		return(Data);
				;148	}
				;149	void _delay(void){
				;150		GCC_NOP();
				__delay:
				__delay:
				@dummy .SECTION 'CODE'
0053	0000	nop
				;151		GCC_NOP();
0054	0000	nop
				;152		GCC_NOP();
0055	0000	nop
				;153		GCC_NOP();
0056	0000	nop
				;154		GCC_NOP();
0057	0000	nop
0058	0003	ret
				;155	}
				;156	
				;157	
				;158	
				;159	
				;file E:\Doing\啟德電子\DriveHT1635Led\source\funscankey.c
				;1	#include "config.h"
				;2	
				;3	volatile unsigned char keyCount;
				;4	
				;5	extern unsigned char modecount;
				;6	extern unsigned char displayState;
				;7	
				;8	void fun_scan_key(void){
				;9		KEYC=1;//key input mode
				_fun_scan_key:
				_fun_scan_key:
0371	321B	set     PAC4
				;10		if (KEY==0)
0372	3E1A	sz      PA4
0373	2B7A	jmp     _L2
				;11		{
				;12			keyCount++;
0374	5485	inc     keyCount[0]
				;13			if(keyCount==4)
0375	4705	mov     a, keyCount[0]
0376	0A04	sub     a, 4H
0377	390A	snz     Z
0378	2B7B	jmp     _L1
				;14			{
				;15				flag_keypush=1;
0379	7006	set     flag_byte0[0].0
				;16				keyCount=0;
				;17			}
				;18		}
				;19		else
				;20		{
				;21			keyCount=0;
				_L2:
037A	5F05	clr     keyCount[0]
				_L1:
037B	0003	ret
				;22		}	
				;23	}
				;24	
				;25	
				;26	void fun_task_key(void){
				;27		if(flag_keypush==1){
				_fun_task_key:
				_fun_task_key:
037C	7806	snz     flag_byte0[0].0
037D	2BA6	jmp     _L5
				;28			flag_keypush=0;
037E	7406	clr     flag_byte0[0].0
				;29			switch(displayState){
037F	4701	mov     a, displayState[0]
0380	0A00	sub     a, 0H
0381	3D0A	sz      Z
0382	2B98	jmp     _L7
0383	0A01	sub     a, 1H
0384	3D0A	sz      Z
0385	2B9B	jmp     _L8
0386	4701	mov     a, displayState[0]
0387	0A02	sub     a, 2H
0388	3D0A	sz      Z
0389	2BA5	jmp     _L9
038A	0A01	sub     a, 1H
038B	3D0A	sz      Z
038C	2B9F	jmp     _L10
038D	4701	mov     a, displayState[0]
038E	0A04	sub     a, 4H
038F	3D0A	sz      Z
0390	2BA2	jmp     _L11
0391	4701	mov     a, displayState[0]
0392	0A05	sub     a, 5H
0393	390A	snz     Z
0394	2BA6	jmp     _L5
				;30				case displayState_Hello:
				;31					displayState=displayState_All;
				_L7:
0398	0F01	mov     a, 1H
0399	4081	mov     displayState[0], a
				;32					break;
039A	2BA6	jmp     _L5
				;33				case displayState_All:
				;34					displayState=displayState_Bink0;
				_L8:
039B	0F03	mov     a, 3H
039C	4081	mov     displayState[0], a
				;35					_updateDisplayBlink();
039D	20F2	call    __updateDisplayBlink
				;36					break;
039E	2BA6	jmp     _L5
				;37				case displayState_Bink0:
				;38					displayState=displayState_Bink1;
				_L10:
039F	0F04	mov     a, 4H
03A0	4081	mov     displayState[0], a
				;39					break;
03A1	2BA6	jmp     _L5
				;40				case displayState_Bink1:
				;41					displayState=displayState_Normal;
				_L11:
03A2	0F05	mov     a, 5H
03A3	4081	mov     displayState[0], a
				;42					break;
03A4	2BA6	jmp     _L5
				;43				case displayState_Normal:
				;44					displayState=displayState_Off;
0395	0F02	mov     a, 2H
0396	4081	mov     displayState[0], a
				;45					break;
0397	2BA6	jmp     _L5
				;46				case displayState_Off:
				;47					displayState=displayState_Hello;
				_L9:
03A5	5F01	clr     displayState[0]
				_L5:
03A6	0003	ret
03A7	1483	inc     MP1
				L03A8:
03A8	3F87	sz      TBLP.7
03A9	2BAE	jmp     L03AE
03AA	0707	mov     a, TBLP
03AB	0084	mov     BP, a
03AC	0702	mov     a, __iar1[0]
03AD	0003	ret
				L03AE:
03AE	0703	mov     a, MP1
03AF	2900	jmp     L0100
				;48					break;
				;49				default:
				;50					break;
				;51			}
				;52		}	
				;53	}
				;54	
				;55	
				;56	
				data .SECTION 'DATA'
				__iar1 DB DUP (?) ; __iar1
				__mp1 DB DUP (?) ; __mp1
				__bp DB DUP (?) ; __bp
				__tblp DB DUP (?) ; __tblp
				__status DB DUP (?) ; __status
				__intc0 DB DUP (?) ; __intc0
				__intc1 DB DUP (?) ; __intc1
				__mfi0 DB DUP (?) ; __mfi0
				__pawu DB DUP (?) ; __pawu
				__papu DB DUP (?) ; __papu
				__pa DB DUP (?) ; __pa
				__pac DB DUP (?) ; __pac
				__pbpu DB DUP (?) ; __pbpu
				__pb DB DUP (?) ; __pb
				__pbc DB DUP (?) ; __pbc
				__pcpu DB DUP (?) ; __pcpu
				__pc DB DUP (?) ; __pc
				__pcc DB DUP (?) ; __pcc
				__pdpu DB DUP (?) ; __pdpu
				__pd DB DUP (?) ; __pd
				__pdc DB DUP (?) ; __pdc
				__pepu DB DUP (?) ; __pepu
				__pe DB DUP (?) ; __pe
				__pec DB DUP (?) ; __pec
				__pfpu DB DUP (?) ; __pfpu
				__pf DB DUP (?) ; __pf
				__pfc DB DUP (?) ; __pfc
				__cp0c DB DUP (?) ; __cp0c
				__cp1c DB DUP (?) ; __cp1c
				__tm0c0 DB DUP (?) ; __tm0c0
				__tm0c1 DB DUP (?) ; __tm0c1
				__tm0al DB DUP (?) ; __tm0al
				__tm0ah DB DUP (?) ; __tm0ah
				BinklState DB DUP (?) ; BinklState
				displayState DB DUP (?) ; displayState
				counter3s DB 2 DUP (?) ; counter3s
				counter10ms DB DUP (?) ; counter10ms
				keyCount DB DUP (?) ; keyCount
				flag_byte0 DB DUP (?) ; flag_byte0
				counter DB DUP (?) ; counter
				ra DB DUP (?)
				r114 DB DUP (?)
				r214 DB DUP (?)
				r314 DB DUP (?)
				count DB DUP (?) ; count
				Data DB DUP (?) ; Data
				command DB DUP (?) ; command
				commandData DB DUP (?) ; commandData
				address DB DUP (?) ; address
				_main_2 DB DUP (?)
